<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.sysbios.knl.Task</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/* 
</span>     2    <span class="comment"> * Copyright (c) 2012, Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> * */</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== Task.xdc ========
</span>    34    <span class="comment"> *
</span>    35    <span class="comment"> */</span>
    36    
    37    <span class=key>package</span> ti.sysbios.knl;
    38    
    39    import xdc.rov.ViewInfo;
    40    
    41    import xdc.runtime.Error;
    42    import xdc.runtime.Assert;
    43    import xdc.runtime.Diags;
    44    import xdc.runtime.Log;
    45    import xdc.runtime.IHeap;
    46    
    47    import ti.sysbios.knl.Queue;
    48    
    49    <span class="xdoc">/*!
</span>    50    <span class="xdoc"> *  ======== Task ========
</span>    51    <span class="xdoc"> *  Task Manager.
</span>    52    <span class="xdoc"> *
</span>    53    <span class="xdoc"> *  The Task module makes available a set of functions that manipulate task
</span>    54    <span class="xdoc"> *  objects accessed through pointers of type {<b>@link</b> #Handle}. Tasks represent
</span>    55    <span class="xdoc"> *  independent threads of control that conceptually execute functions in
</span>    56    <span class="xdoc"> *  parallel within a single C program; in reality, concurrency is achieved
</span>    57    <span class="xdoc"> *  by switching the processor from one task to another.
</span>    58    <span class="xdoc"> *
</span>    59    <span class="xdoc"> *  When you create a task, it is provided with its own run-time stack,
</span>    60    <span class="xdoc"> *  used for storing local variables as well as for further nesting of
</span>    61    <span class="xdoc"> *  function calls. Each stack must be large enough to handle normal
</span>    62    <span class="xdoc"> *  subroutine calls and one task preemption context.
</span>    63    <span class="xdoc"> *  A task preemption context is the context that gets saved when one task
</span>    64    <span class="xdoc"> *  preempts another as a result of an interrupt thread readying
</span>    65    <span class="xdoc"> *  a higher-priority task.
</span>    66    <span class="xdoc"> *
</span>    67    <span class="xdoc"> *  All tasks executing within a single program share a common set of
</span>    68    <span class="xdoc"> *  global variables, accessed according to the standard rules of scope
</span>    69    <span class="xdoc"> *  defined for C functions.
</span>    70    <span class="xdoc"> *
</span>    71    <span class="xdoc"> *  Each task is in one of five modes of execution at any point in time:
</span>    72    <span class="xdoc"> *  running, ready, blocked, terminated, or inactive. By design, there is 
</span>    73    <span class="xdoc"> *  always one
</span>    74    <span class="xdoc"> *  (and only one) task currently running, even if it is only the idle task
</span>    75    <span class="xdoc"> *  managed internally by Task. The current task can be suspended from
</span>    76    <span class="xdoc"> *  execution by calling certain Task functions, as well as functions
</span>    77    <span class="xdoc"> *  provided by other modules like the Semaphore or Event Modules. 
</span>    78    <span class="xdoc"> *  The current task
</span>    79    <span class="xdoc"> *  can also terminate its own execution. In either case, the processor
</span>    80    <span class="xdoc"> *  is switched to the highest priority task that is ready to run.
</span>    81    <span class="xdoc"> *
</span>    82    <span class="xdoc"> *  You can assign numeric priorities to tasks. Tasks are
</span>    83    <span class="xdoc"> *  readied for execution in strict priority order; tasks of the same
</span>    84    <span class="xdoc"> *  priority are scheduled on a first-come, first-served basis. 
</span>    85    <span class="xdoc"> *  The priority of the currently running task is never lower
</span>    86    <span class="xdoc"> *  than the priority of any ready task. Conversely, the running task
</span>    87    <span class="xdoc"> *  is preempted and re-scheduled for execution whenever there exists
</span>    88    <span class="xdoc"> *  some ready task of higher priority.
</span>    89    <span class="xdoc"> *
</span>    90    <span class="xdoc"> *  <b>@a(Task Deletion)</b>
</span>    91    <span class="xdoc"> *
</span>    92    <span class="xdoc"> *  Any dynamically created task that is not in the Task_Mode_RUNNING 
</span>    93    <span class="xdoc"> *  state (ie not the currently running task) can be deleted using the 
</span>    94    <span class="xdoc"> *  {<b>@link</b> #delete} API. 
</span>    95    <span class="xdoc"> *
</span>    96    <span class="xdoc"> *  Task_delete() removes the task from all internal queues and calls
</span>    97    <span class="xdoc"> *  Memory_free() to free the task object and stack.
</span>    98    <span class="xdoc"> *  Memory_free() must acquire a lock to the memory before proceeding. 
</span>    99    <span class="xdoc"> *  If another task already holds a lock to the memory, then there is 
</span>   100    <span class="xdoc"> *  a context switch.
</span>   101    <span class="xdoc"> *  
</span>   102    <span class="xdoc"> *  You can specify application-wide Delete hook functions that
</span>   103    <span class="xdoc"> *  run whenever a task is deleted. See the discussion of Hook Functions
</span>   104    <span class="xdoc"> *  below for details.
</span>   105    <span class="xdoc"> *  
</span>   106    <span class="xdoc"> *  Note: Unless the mode of the deleted task is Task_Mode_TERMINATED,
</span>   107    <span class="xdoc"> *  Task_delete should be called with care. For example, if the task has
</span>   108    <span class="xdoc"> *  obtained exclusive access to a resource, deleting the task makes the
</span>   109    <span class="xdoc"> *  resource unavailable.
</span>   110    <span class="xdoc"> *  
</span>   111    <span class="xdoc"> *  Task_delete() constraints:
</span>   112    <span class="xdoc">
</span>   113    <span class="xdoc"> *  <b>@p(blist)</b>
</span>   114    <span class="xdoc"> *  -The task cannot be the currently executing task (Task_self()).
</span>   115    <span class="xdoc"> *  -Task_delete cannot be called from a Swi or Hwi.
</span>   116    <span class="xdoc"> *  -No check is performed to prevent Task_delete from being used on a
</span>   117    <span class="xdoc"> *  statically-created object. If a program attempts to delete a task object
</span>   118    <span class="xdoc"> *  that was created statically, the Memory_free() call will result in an
</span>   119    <span class="xdoc"> *  assertion failure in its corresponding Heap manager, causing the 
</span>   120    <span class="xdoc"> *  application to exit.
</span>   121    <span class="xdoc"> *  <b>@p</b>
</span>   122    <span class="xdoc"> *  
</span>   123    <span class="xdoc"> *  <b>@a(Stack Alignment)</b>
</span>   124    <span class="xdoc"> *  
</span>   125    <span class="xdoc"> *  Stack size parameters for both static and dynamic tasks are rounded
</span>   126    <span class="xdoc"> *  up to the nearest integer multiple of a target-specific alignment
</span>   127    <span class="xdoc"> *  requirement.
</span>   128    <span class="xdoc"> *  
</span>   129    <span class="xdoc"> *  In the case of Task's which are created with a user-provided stack,
</span>   130    <span class="xdoc"> *  both the base address and the stackSize are aligned. The base address
</span>   131    <span class="xdoc"> *  is increased to the nearest aligned address. The stack size is decreased
</span>   132    <span class="xdoc"> *  accordingly and then rounded down to the nearest integer multiple of the 
</span>   133    <span class="xdoc"> *  target-specific required alignment.
</span>   134    <span class="xdoc"> *
</span>   135    <span class="xdoc"> *  <b>@p(html)</b>
</span>   136    <span class="xdoc"> *  &lt;a name="hookfunc"&gt;&lt;/a&gt;
</span>   137    <span class="xdoc"> *  <b>@p</b>
</span>   138    <span class="xdoc"> *
</span>   139    <span class="xdoc"> *  <b>@a(Hook Functions)</b>
</span>   140    <span class="xdoc"> *
</span>   141    <span class="xdoc"> *  Sets of hook functions can be specified for the Task module.  Each
</span>   142    <span class="xdoc"> *  set can contains these hook functions:
</span>   143    <span class="xdoc"> *  <b>@p(blist)</b>
</span>   144    <span class="xdoc"> *  -Register: A function called before any statically created tasks
</span>   145    <span class="xdoc"> *      are initialized at runtime.  The register hook is called at boot time
</span>   146    <span class="xdoc"> *      before main() and before interrupts are enabled.
</span>   147    <span class="xdoc"> *  -Create: A function that is called when a task is created. 
</span>   148    <span class="xdoc"> *      This includes tasks that are created statically and those
</span>   149    <span class="xdoc"> *      created dynamically using {<b>@link</b> #create} or {<b>@link</b> #construct}.
</span>   150    <span class="xdoc"> *      The create hook is called outside of a Task_disable/enable block and
</span>   151    <span class="xdoc"> *   before the task has been added to the ready list.
</span>   152    <span class="xdoc"> *  -Ready: A function that is called when a task becomes ready to run.
</span>   153    <span class="xdoc"> *   The ready hook is called from within a Task_disable/enable block with
</span>   154    <span class="xdoc"> *   interrupts enabled.
</span>   155    <span class="xdoc"> *  -Switch: A function that is called just before a task switch
</span>   156    <span class="xdoc"> *      occurs. The 'prev' and 'next' task handles are passed to the Switch
</span>   157    <span class="xdoc"> *      hook. 'prev' is set to NULL for the initial task switch that occurs
</span>   158    <span class="xdoc"> *      during SYS/BIOS startup.  The Switch hook is called from within a
</span>   159    <span class="xdoc"> *      Task_disable/enable block with interrupts enabled.
</span>   160    <span class="xdoc"> *  -Exit:      A function that is called when a task exits using
</span>   161    <span class="xdoc"> *      {<b>@link</b> #exit}.  The exit hook is passed the handle of the exiting
</span>   162    <span class="xdoc"> *      task.  The exit hook is called outside of a Task_disable/enable block
</span>   163    <span class="xdoc"> *      and before the task has been removed from the kernel lists.
</span>   164    <span class="xdoc"> *  -Delete: A function that is called when any task is deleted at
</span>   165    <span class="xdoc"> *      run-time with {<b>@link</b> #delete}.  The delete hook is called outside
</span>   166    <span class="xdoc"> *      of a Task_disable/enable block.
</span>   167    <span class="xdoc"> *  <b>@p</b>
</span>   168    <span class="xdoc"> *  Hook functions can only be configured statically.
</span>   169    <span class="xdoc"> *
</span>   170    <span class="xdoc"> *  If you define more than one set of hook functions, all the functions
</span>   171    <span class="xdoc"> *  of a particular type will be run when a Swi triggers that type of 
</span>   172    <span class="xdoc"> *  hook.
</span>   173    <span class="xdoc"> *
</span>   174    <span class="xdoc"> *  <b>@p(html)</b>
</span>   175    <span class="xdoc"> *  &lt;B&gt;Register Function&lt;/B&gt;
</span>   176    <span class="xdoc"> *  <b>@p</b>
</span>   177    <span class="xdoc"> *
</span>   178    <span class="xdoc"> *  The Register function is provided to allow a hook set to store its
</span>   179    <span class="xdoc"> *  hookset ID.  This id can be passed to {<b>@link</b> #setHookContext} and 
</span>   180    <span class="xdoc"> *  {<b>@link</b> #getHookContext} to set or get hookset-specific context.  The
</span>   181    <span class="xdoc"> *  Register function must be specified if the hook implementation
</span>   182    <span class="xdoc"> *  needs to use {<b>@link</b> #setHookContext} or {<b>@link</b> #getHookContext}.
</span>   183    <span class="xdoc"> *  The registerFxn hook function is called during system initialization
</span>   184    <span class="xdoc"> *  before interrupts have been enabled. 
</span>   185    <span class="xdoc"> *
</span>   186    <span class="xdoc"> *  <b>@p(code)</b>
</span>   187    <span class="xdoc"> *  Void myRegisterFxn(Int id);
</span>   188    <span class="xdoc"> *  <b>@p</b>
</span>   189    <span class="xdoc"> *
</span>   190    <span class="xdoc"> *  <b>@p(html)</b>
</span>   191    <span class="xdoc"> *  &lt;B&gt;Create and Delete Functions&lt;/B&gt;
</span>   192    <span class="xdoc"> *  <b>@p</b>
</span>   193    <span class="xdoc"> *
</span>   194    <span class="xdoc"> *  The create and delete functions are called whenever a Task is created
</span>   195    <span class="xdoc"> *  or deleted.  They are called with interrupts enabled (unless called 
</span>   196    <span class="xdoc"> *  at boot time or from main()).
</span>   197    <span class="xdoc"> *
</span>   198    <span class="xdoc"> *  <b>@p(code)</b>
</span>   199    <span class="xdoc"> *  Void myCreateFxn(Task_Handle task, Error_Block *eb);
</span>   200    <span class="xdoc"> *  <b>@p</b>
</span>   201    <span class="xdoc"> *
</span>   202    <span class="xdoc"> *  <b>@p(code)</b>
</span>   203    <span class="xdoc"> *  Void myDeleteFxn(Task_Handle task);
</span>   204    <span class="xdoc"> *  <b>@p</b>
</span>   205    <span class="xdoc"> *
</span>   206    <span class="xdoc"> *  <b>@p(html)</b>
</span>   207    <span class="xdoc"> *  &lt;B&gt;Switch Function&lt;/B&gt;
</span>   208    <span class="xdoc"> *  <b>@p</b>
</span>   209    <span class="xdoc"> *
</span>   210    <span class="xdoc"> *  If a switch function is specified, it is invoked just before the new task
</span>   211    <span class="xdoc"> *  is switched to.  The switch function is called with interrupts enabled.
</span>   212    <span class="xdoc"> *
</span>   213    <span class="xdoc"> *  This function can be used to save/restore additional task context (for
</span>   214    <span class="xdoc"> *  example, external hardware registers), to check for task stack overflow,
</span>   215    <span class="xdoc"> *  to monitor the time used by each task, etc.
</span>   216    <span class="xdoc"> *
</span>   217    <span class="xdoc"> *  <b>@p(code)</b>
</span>   218    <span class="xdoc"> *  Void mySwitchFxn(Task_Handle prev, Task_Handle next);
</span>   219    <span class="xdoc"> *  <b>@p</b>
</span>   220    <span class="xdoc"> *
</span>   221    <span class="xdoc"> *  To properly handle the switch to the first task your switchFxn should
</span>   222    <span class="xdoc"> *  check for "prev == NULL" before using prev:
</span>   223    <span class="xdoc"> *
</span>   224    <span class="xdoc"> *  <b>@p(code)</b>
</span>   225    <span class="xdoc"> *  Void mySwitchFxn(Task_Handle prev, Task_Handle next)
</span>   226    <span class="xdoc"> *  {
</span>   227    <span class="xdoc"> *      if (prev != NULL) {
</span>   228    <span class="xdoc"> *          ...
</span>   229    <span class="xdoc"> *      }
</span>   230    <span class="xdoc"> *      ...
</span>   231    <span class="xdoc"> *  }
</span>   232    <span class="xdoc"> *  <b>@p</b>
</span>   233    <span class="xdoc"> *
</span>   234    <span class="xdoc"> *  <b>@p(html)</b>
</span>   235    <span class="xdoc"> *  &lt;B&gt;Ready Function&lt;/B&gt;
</span>   236    <span class="xdoc"> *  <b>@p</b>
</span>   237    <span class="xdoc"> *
</span>   238    <span class="xdoc"> *  If a ready function is specified, it is invoked whenever a task is made
</span>   239    <span class="xdoc"> *  ready to run.   The ready function is called  with interrupts enabled
</span>   240    <span class="xdoc"> *  (unless called at boot time or from main()).
</span>   241    <span class="xdoc"> *
</span>   242    <span class="xdoc"> *  <b>@p(code)</b>
</span>   243    <span class="xdoc"> *  Void myReadyFxn(Task_Handle task);
</span>   244    <span class="xdoc"> *  <b>@p</b>
</span>   245    <span class="xdoc"> * 
</span>   246    <span class="xdoc"> *  <b>@p(html)</b>
</span>   247    <span class="xdoc"> *  &lt;B&gt;Exit Function&lt;/B&gt;
</span>   248    <span class="xdoc"> *  <b>@p</b>
</span>   249    <span class="xdoc"> *
</span>   250    <span class="xdoc"> *  If an exit function is specified, it is invoked when a task exits (via
</span>   251    <span class="xdoc"> *  call to Task_exit() or when a task returns from its' main function).
</span>   252    <span class="xdoc"> *  The Exit Function is called with interrupts enabled. 
</span>   253    <span class="xdoc"> *
</span>   254    <span class="xdoc"> *  <b>@p(code)</b>
</span>   255    <span class="xdoc"> *  Void myExitFxn(Task_Handle task);
</span>   256    <span class="xdoc"> *  <b>@p</b>
</span>   257    <span class="xdoc"> *
</span>   258    <span class="xdoc"> *  <b>@p(html)</b>
</span>   259    <span class="xdoc"> *  &lt;h3&gt; Calling Context &lt;/h3&gt;
</span>   260    <span class="xdoc"> *  &lt;table border="1" cellpadding="3"&gt;
</span>   261    <span class="xdoc"> *    &lt;colgroup span="1"&gt;&lt;/colgroup&gt; &lt;colgroup span="5" align="center"&gt;
</span>   262    <span class="xdoc"> *  &lt;/colgroup&gt;
</span>   263    <span class="xdoc"> *    
</span>   264    <span class="xdoc"> *    &lt;tr&gt;&lt;th&gt; Function                 &lt;/th&gt;&lt;th&gt;  Hwi   &lt;/th&gt;&lt;th&gt;  Swi   &lt;/th&gt;
</span>   265    <span class="xdoc"> *  &lt;th&gt;  Task  &lt;/th&gt;&lt;th&gt;  Main  &lt;/th&gt;&lt;th&gt;  Startup  &lt;/th&gt;&lt;/tr&gt;
</span>   266    <span class="xdoc"> *    &lt;!--                                                       --&gt;
</span>   267    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #create}          &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   268    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   269    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #disable}         &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   270    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   271    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #exit}            &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   272    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   273    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getIdleTask}     &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   274    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   275    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #Params_init}     &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   276    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   277    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #restore}         &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   278    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   279    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #self}            &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   280    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   281    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #sleep}           &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   282    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   283    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #yield}           &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   284    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   285    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #construct}       &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   286    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   287    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #delete}          &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   288    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   289    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #destruct}        &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   290    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   291    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getEnv}          &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   292    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   293    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getHookContext}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   294    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   295    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getMode}         &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   296    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   297    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getPri}          &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   298    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   299    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setEnv}          &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   300    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   301    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setHookContext}  &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   302    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   303    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setPri}          &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   304    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   305    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #stat}            &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   306    <span class="xdoc"> *  &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   307    <span class="xdoc"> *    &lt;tr&gt;&lt;td colspan="6"&gt; Definitions: &lt;br /&gt;
</span>   308    <span class="xdoc"> *       &lt;ul&gt;
</span>   309    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Hwi&lt;/b&gt;: API is callable from a Hwi thread. &lt;/li&gt;
</span>   310    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Swi&lt;/b&gt;: API is callable from a Swi thread. &lt;/li&gt;
</span>   311    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Task&lt;/b&gt;: API is callable from a Task thread. &lt;/li&gt;
</span>   312    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Main&lt;/b&gt;: API is callable during any of these phases: &lt;/li&gt;
</span>   313    <span class="xdoc"> *           &lt;ul&gt;
</span>   314    <span class="xdoc"> *             &lt;li&gt; In your module startup after this module is started 
</span>   315    <span class="xdoc"> *  (e.g. Task_Module_startupDone() returns TRUE). &lt;/li&gt;
</span>   316    <span class="xdoc"> *             &lt;li&gt; During xdc.runtime.Startup.lastFxns. &lt;/li&gt;
</span>   317    <span class="xdoc"> *             &lt;li&gt; During main().&lt;/li&gt;
</span>   318    <span class="xdoc"> *             &lt;li&gt; During BIOS.startupFxns.&lt;/li&gt;
</span>   319    <span class="xdoc"> *           &lt;/ul&gt;
</span>   320    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Startup&lt;/b&gt;: API is callable during any of these phases:&lt;/li&gt;
</span>   321    <span class="xdoc"> *           &lt;ul&gt;
</span>   322    <span class="xdoc"> *             &lt;li&gt; During xdc.runtime.Startup.firstFxns.&lt;/li&gt;
</span>   323    <span class="xdoc"> *             &lt;li&gt; In your module startup before this module is started 
</span>   324    <span class="xdoc"> *  (e.g. Task_Module_startupDone() returns FALSE).&lt;/li&gt;
</span>   325    <span class="xdoc"> *           &lt;/ul&gt;
</span>   326    <span class="xdoc"> *       &lt;/ul&gt;
</span>   327    <span class="xdoc"> *    &lt;/td&gt;&lt;/tr&gt;
</span>   328    <span class="xdoc"> *  
</span>   329    <span class="xdoc"> *  &lt;/table&gt;
</span>   330    <span class="xdoc"> *  <b>@p</b>
</span>   331    <span class="xdoc"> */</span>
   332    
   333    @ModuleStartup      <span class="comment">/* generate a call to Task_Module_startup at startup */</span>
   334    @InstanceFinalize   <span class="comment">/* generate call to Task_Instance_finalize on delete */</span>
   335    @InstanceInitError  <span class="comment">/* instance init can fail */</span>
   336    
   337    <span class=key>module</span> Task
   338    {
   339    
   340        <span class=comment>// -------- Module Constants --------</span>
   341    
   342        <span class=comment>// -------- Module Types --------</span>
   343    
   344        <span class="xdoc">/*! Task function type definition. */</span>
   345        <span class=key>typedef</span> Void (*FuncPtr)(UArg, UArg);
   346    
   347        <span class="xdoc">/*! "All Task Blocked" function type definition. */</span>
   348        <span class=key>typedef</span> Void (*AllBlockedFuncPtr)(Void);
   349    
   350        <span class="xdoc">/*! 
</span>   351    <span class="xdoc">     *  Task execution modes. 
</span>   352    <span class="xdoc">     *
</span>   353    <span class="xdoc">     *  These enumerations are the range of modes or states that 
</span>   354    <span class="xdoc">     *  a task can be in. A task's current mode can be gotten using
</span>   355    <span class="xdoc">     *  {<b>@link</b> #stat}.
</span>   356    <span class="xdoc">     */</span>
   357        <span class=key>enum</span> Mode {
   358            Mode_RUNNING,           <span class="xdoc">/*! Task is currently executing. */</span>
   359            Mode_READY,             <span class="xdoc">/*! Task is scheduled for execution. */</span>
   360            Mode_BLOCKED,           <span class="xdoc">/*! Task is suspended from execution. */</span>
   361            Mode_TERMINATED,        <span class="xdoc">/*! Task is terminated from execution. */</span>
   362            Mode_INACTIVE           <span class="xdoc">/*! Task is on inactive task list */</span>
   363        };
   364    
   365        <span class="xdoc">/*! 
</span>   366    <span class="xdoc">     *  Task Status Buffer. 
</span>   367    <span class="xdoc">     *
</span>   368    <span class="xdoc">     *  Passed to and filled in by {<b>@link</b> #stat};
</span>   369    <span class="xdoc">     */</span>
   370        <span class=key>struct</span> Stat {
   371            Int     priority;       <span class="xdoc">/*! Task priority. */</span>
   372            Ptr     stack;          <span class="xdoc">/*! Task stack. */</span>
   373            SizeT   stackSize;      <span class="xdoc">/*! Task stack size. */</span>
   374            IHeap.Handle stackHeap; <span class="xdoc">/*! Heap used to alloc stack. */</span>
   375            Ptr     env;            <span class="xdoc">/*! Global environment struct. */</span>
   376            Mode    mode;           <span class="xdoc">/*! Task's current mode. */</span>
   377            Ptr     sp;             <span class="xdoc">/*! Task's current stack pointer. */</span>
   378            SizeT   used;           <span class="xdoc">/*! max # of words used on stack. */</span>
   379        };
   380    
   381        <span class="xdoc">/*! 
</span>   382    <span class="xdoc">     *  Task hook set type definition.
</span>   383    <span class="xdoc">     * 
</span>   384    <span class="xdoc">     *  Sets of hook functions can be specified for the Task module. 
</span>   385    <span class="xdoc">     *  See {<b>@link</b> #hookfunc Hook Functions} for details. 
</span>   386    <span class="xdoc">     */</span>
   387        <span class=key>struct</span> HookSet {
   388            Void (*registerFxn)(Int);
   389            Void (*createFxn)(Handle, Error.Block *);       
   390            Void (*readyFxn)(Handle);
   391            Void (*switchFxn)(Handle, Handle);
   392            Void (*exitFxn)(Handle);
   393            Void (*deleteFxn)(Handle);
   394        };
   395    
   396        <span class="xdoc">/*!  <b>@_nodoc</b> */</span>
   397        <span class=key>metaonly</span> <span class=key>struct</span> BasicView {
   398            String      label;
   399            Int         priority;
   400            String      mode;
   401            String      fxn[]; 
   402            UArg        arg0; 
   403            UArg        arg1; 
   404            SizeT       stackSize;
   405            Ptr         stackBase; 
   406        }
   407        
   408        <span class="xdoc">/*!  <b>@_nodoc</b> */</span>
   409        <span class=key>metaonly</span> <span class=key>struct</span> DetailedView {
   410            String      label;
   411            Int         priority;
   412            String      mode;
   413            String      fxn[]; 
   414            UArg        arg0; 
   415            UArg        arg1; 
   416            SizeT       stackPeak;
   417            SizeT       stackSize;
   418            Ptr         stackBase; 
   419            String      blockedOn;
   420        }
   421    
   422        <span class="xdoc">/*!  <b>@_nodoc</b> */</span>
   423        <span class=key>metaonly</span> <span class=key>struct</span> ModuleView {
   424            String      schedulerState;
   425            String      readyQMask;
   426            Bool        workPending;
   427            UInt        numVitalTasks;
   428            Ptr         currentTask;
   429            SizeT       hwiStackPeak;
   430            SizeT       hwiStackSize;
   431            Ptr         hwiStackBase;
   432        }
   433           
   434        <span class="xdoc">/*! <b>@_nodoc</b> */</span>
   435        @Facet
   436        <span class=key>metaonly</span> <span class=key>config</span> ViewInfo.Instance rovViewInfo = 
   437            ViewInfo.create({
   438                viewMap: [
   439                    [<span class="string">'Basic'</span>,    {type: ViewInfo.INSTANCE, viewInitFxn: <span class="string">'viewInitBasic'</span>,    structName: <span class="string">'BasicView'</span>}],
   440                    [<span class="string">'Detailed'</span>, {type: ViewInfo.INSTANCE, viewInitFxn: <span class="string">'viewInitDetailed'</span>, structName: <span class="string">'DetailedView'</span>}],
   441                    [<span class="string">'Module'</span>,   {type: ViewInfo.MODULE,   viewInitFxn: <span class="string">'viewInitModule'</span>,   structName: <span class="string">'ModuleView'</span>}],
   442                ]
   443            });
   444    
   445        <span class=comment>// -------- Module Parameters --------</span>
   446    
   447        <span class=comment>// Logs</span>
   448        
   449        <span class="xdoc">/*! Logged on every task switch */</span>
   450        <span class=key>config</span> Log.Event LM_switch = {
   451            mask: Diags.USER1 | Diags.USER2,
   452            msg: <span class="string">"LM_switch: oldtsk: 0x%x, oldfunc: 0x%x, newtsk: 0x%x, newfunc: 0x%x"</span>
   453        };
   454    
   455        <span class="xdoc">/*! Logged on calls to Task_sleep */</span>
   456        <span class=key>config</span> Log.Event LM_sleep = {
   457            mask: Diags.USER1 | Diags.USER2,
   458            msg: <span class="string">"LM_sleep: tsk: 0x%x, func: 0x%x, timeout: %d"</span>
   459        };
   460    
   461        <span class="xdoc">/*! Logged when a task is made ready to run (ie Semaphore_post()) */</span>
   462        <span class=key>config</span> Log.Event LD_ready = {
   463            mask: Diags.USER2,
   464            msg: <span class="string">"LD_ready: tsk: 0x%x, func: 0x%x, pri: %d"</span>
   465        };
   466    
   467        <span class="xdoc">/*! Logged when a task is blocked (ie Semaphore_pend()) */</span>
   468        <span class=key>config</span> Log.Event LD_block = {
   469            mask: Diags.USER2,
   470            msg: <span class="string">"LD_block: tsk: 0x%x, func: 0x%x"</span>
   471        };
   472    
   473        <span class="xdoc">/*! Logged on calls to Task_yield */</span>
   474        <span class=key>config</span> Log.Event LM_yield = {
   475            mask: Diags.USER1 | Diags.USER2,
   476            msg: <span class="string">"LM_yield: tsk: 0x%x, func: 0x%x, currThread: %d"</span>
   477        };
   478    
   479        <span class="xdoc">/*! Logged on calls to Task_setPri */</span>
   480        <span class=key>config</span> Log.Event LM_setPri = {
   481            mask: Diags.USER1 | Diags.USER2,
   482            msg: <span class="string">"LM_setPri: tsk: 0x%x, func: 0x%x, oldPri: %d, newPri %d"</span>
   483        };
   484    
   485        <span class="xdoc">/*! 
</span>   486    <span class="xdoc">     *  Logged when Task functions fall thru the bottom 
</span>   487    <span class="xdoc">     *  or when Task_exit() is explicitly called.
</span>   488    <span class="xdoc">     */</span>
   489        <span class=key>config</span> Log.Event LD_exit = {
   490            mask: Diags.USER2,
   491            msg: <span class="string">"LD_exit: tsk: 0x%x, func: 0x%x"</span>
   492        };
   493    
   494        <span class=comment>// Errors</span>
   495    
   496        <span class="xdoc">/*! 
</span>   497    <span class="xdoc">     *  Error raised when a stack overflow (or corruption) is detected.
</span>   498    <span class="xdoc">     *
</span>   499    <span class="xdoc">     *  This error is raised by kernel's stack checking function.  This
</span>   500    <span class="xdoc">     *  function checks the stacks before every task switch to make sure
</span>   501    <span class="xdoc">     *  that reserved word at top of stack has not been modified.
</span>   502    <span class="xdoc">     *
</span>   503    <span class="xdoc">     *  The stack checking logic is enabled by the {<b>@link</b> #initStackFlag} and
</span>   504    <span class="xdoc">     *  {<b>@link</b> #checkStackFlag} configuration parameters.  If both of these
</span>   505    <span class="xdoc">     *  flags are set to true, the kernel will validate the stacks.
</span>   506    <span class="xdoc">     */</span>
   507        <span class=key>config</span> Error.Id E_stackOverflow  = {
   508            msg: <span class="string">"E_stackOverflow: Task 0x%x stack overflow."</span>
   509        };
   510    
   511        <span class="xdoc">/*! 
</span>   512    <span class="xdoc">     *  Error raised when a task's stack pointer (SP) does not point
</span>   513    <span class="xdoc">     *  somewhere within the task's stack.
</span>   514    <span class="xdoc">     *
</span>   515    <span class="xdoc">     *  This error is raised by kernel's stack checking function.  This
</span>   516    <span class="xdoc">     *  function checks the SPs before every task switch to make sure
</span>   517    <span class="xdoc">     *  they point within the task's stack.
</span>   518    <span class="xdoc">     *
</span>   519    <span class="xdoc">     *  The stack checking logic is enabled by the {<b>@link</b> #initStackFlag} and
</span>   520    <span class="xdoc">     *  {<b>@link</b> #checkStackFlag} configuration parameters.  If both of these
</span>   521    <span class="xdoc">     *  flags are set to true, the kernel will validate the stack pointers.
</span>   522    <span class="xdoc">     */</span>
   523        <span class=key>config</span> Error.Id E_spOutOfBounds  = {
   524            msg: <span class="string">"E_spOutOfBounds: Task 0x%x stack error, SP = 0x%x."</span>
   525        };
   526    
   527        <span class=comment>// Asserts</span>
   528    
   529        <span class="xdoc">/*! Asserted in Task_create and Task_delete */</span>
   530        <span class=key>config</span> Assert.Id A_badThreadType = {
   531            msg: <span class="string">"A_badThreadType: Cannot create/delete a task from Hwi or Swi thread."</span>
   532        };
   533    
   534        <span class="xdoc">/*! Asserted in Task_delete */</span>
   535        <span class=key>config</span> Assert.Id A_badTaskState = {
   536            msg: <span class="string">"A_badTaskState: Can't delete a task in RUNNING state."</span>
   537        };
   538    
   539        <span class="xdoc">/*! Asserted in Task_delete */</span>
   540        <span class=key>config</span> Assert.Id A_noPendElem = {
   541            msg: <span class="string">"A_noPendElem: Not enough info to delete BLOCKED task."</span>
   542        };
   543    
   544        <span class="xdoc">/*! Asserted in Task_create */</span>
   545        <span class=key>config</span> Assert.Id A_taskDisabled = {
   546            msg: <span class="string">"A_taskDisabled: Cannot create a task when tasking is disabled."</span>
   547        };
   548    
   549        <span class="xdoc">/*! Asserted in Task_create */</span>
   550        <span class=key>config</span> Assert.Id A_badPriority = {
   551            msg: <span class="string">"A_badPriority: An invalid task priority was used."</span>
   552        };
   553    
   554        <span class="xdoc">/*! Asserted in Task_sleep */</span>
   555        <span class=key>config</span> Assert.Id A_badTimeout = {
   556            msg: <span class="string">"A_badTimeout: Can't sleep FOREVER."</span>
   557        };
   558    
   559        <span class="xdoc">/*! 
</span>   560    <span class="xdoc">     *  Number of Task priorities supported. Default is 16.
</span>   561    <span class="xdoc">     *
</span>   562    <span class="xdoc">     *  The maximum number of priorities supported is
</span>   563    <span class="xdoc">     *  target specific and depends on the number of 
</span>   564    <span class="xdoc">     *  bits in a UInt data type. For 6x and ARM devices
</span>   565    <span class="xdoc">     *  the maximum number of priorities is therefore 32.
</span>   566    <span class="xdoc">     *  For 28x, 55x, and MSP430 devices, the maximum number of
</span>   567    <span class="xdoc">     *  priorities is 16.
</span>   568    <span class="xdoc">     */</span>
   569        <span class=key>config</span> UInt numPriorities = 16;
   570    
   571        <span class="xdoc">/*!
</span>   572    <span class="xdoc">     *  Default stack size (in MAUs) used for all tasks.
</span>   573    <span class="xdoc">     *
</span>   574    <span class="xdoc">     *  Default is obtained from the family-specific TaskSupport module 
</span>   575    <span class="xdoc">      *  (e.g. {<b>@link</b> ti.sysbios.family.arm.m3.TaskSupport}, 
</span>   576    <span class="xdoc">      *  {<b>@link</b> ti.sysbios.family.c62.TaskSupport}).
</span>   577    <span class="xdoc">     */</span>
   578        <span class=key>config</span> SizeT defaultStackSize;
   579    
   580        <span class="xdoc">/*!
</span>   581    <span class="xdoc">     *  Default memory section used for all statically created task stacks.
</span>   582    <span class="xdoc">     *
</span>   583    <span class="xdoc">     *  The default stack section name is target/device specific.
</span>   584    <span class="xdoc">     *  For C6x targets it is ".far:taskStackSection".
</span>   585    <span class="xdoc">     *  For C28x targets it is ".taskStackSection".
</span>   586    <span class="xdoc">     *  For all other targets it is ".bss:taskStackSection".
</span>   587    <span class="xdoc">     *
</span>   588    <span class="xdoc">     *  By default, all statically created task stacks are grouped together
</span>   589    <span class="xdoc">     *  into the defaultStackSection and placed where ever
</span>   590    <span class="xdoc">     *  the target specific defaultStackSection base section name 
</span>   591    <span class="xdoc">     *  (ie .bss, .far, .ebss) is placed.
</span>   592    <span class="xdoc">     *
</span>   593    <span class="xdoc">     *  To place all task stacks into a different memory segment, 
</span>   594    <span class="xdoc">     *  add the following to your config script:
</span>   595    <span class="xdoc">     *
</span>   596    <span class="xdoc">     *  <b>@p(code)</b>
</span>   597    <span class="xdoc">     *  Program.sectMap[Task.defaultStackSection] = new Program.SectionSpec();
</span>   598    <span class="xdoc">     *  Program.sectMap[Task.defaultStackSection].loadSegment = 
</span>   599    <span class="xdoc">     *                   "yourMemorySegment";
</span>   600    <span class="xdoc">     *  <b>@p</b>
</span>   601    <span class="xdoc">     *
</span>   602    <span class="xdoc">     *  To group all task stacks into a different section AND place that 
</span>   603    <span class="xdoc">     *  section into a specific memory segment, add the following to your 
</span>   604    <span class="xdoc">     *  config script:
</span>   605    <span class="xdoc">     *
</span>   606    <span class="xdoc">     *  <b>@p(code)</b>
</span>   607    <span class="xdoc">     *  Task.defaultStackSection = ".yourSectionName";
</span>   608    <span class="xdoc">     *  Program.sectMap[Task.defaultStackSection] = new Program.SectionSpec();
</span>   609    <span class="xdoc">     *  Program.sectMap[Task.defaultStackSection].loadSegment =
</span>   610    <span class="xdoc">     *                   "yourMemorySegment";
</span>   611    <span class="xdoc">     *  <b>@p</b>
</span>   612    <span class="xdoc">     *
</span>   613    <span class="xdoc">     *  Where "yourSectionName" can be just about anything, and
</span>   614    <span class="xdoc">     *                   "yourMemorySegment" 
</span>   615    <span class="xdoc">     *  must be a memory segment defined for your board.
</span>   616    <span class="xdoc">     */</span>
   617        <span class=key>metaonly</span> <span class=key>config</span> String defaultStackSection;
   618    
   619        <span class="xdoc">/*!
</span>   620    <span class="xdoc">     *  Default Mem heap used for all dynamically created task stacks.
</span>   621    <span class="xdoc">     *
</span>   622    <span class="xdoc">     *  Default is null.
</span>   623    <span class="xdoc">     */</span>
   624        <span class=key>config</span> IHeap.Handle defaultStackHeap;
   625    
   626        <span class="xdoc">/*! 
</span>   627    <span class="xdoc">     *  Create a task (of priority 0) to run the Idle functions in.
</span>   628    <span class="xdoc">     *
</span>   629    <span class="xdoc">     *  When set to true, a task is created that continuously calls the 
</span>   630    <span class="xdoc">     *  {<b>@link</b> Idle#run Idle_run()} function, which, in turn calls each of
</span>   631    <span class="xdoc">     *  the configured Idle functions. 
</span>   632    <span class="xdoc">     *
</span>   633    <span class="xdoc">     *  When set to false, no Idle Task is created and it is up to the
</span>   634    <span class="xdoc">     *  user to call the Idle_run() function if the configured Idle 
</span>   635    <span class="xdoc">     *  functions need to be run. Or, by adding the following lines to
</span>   636    <span class="xdoc">     *  the config script, the Idle functions will run whenever all
</span>   637    <span class="xdoc">     *  tasks are blocked ({<b>@link</b> #allBlockedFunc Task.allBlockedFunc}):
</span>   638    <span class="xdoc">     *
</span>   639    <span class="xdoc">     *  <b>@p(code)</b>
</span>   640    <span class="xdoc">     *  Task.enableIdleTask = false;
</span>   641    <span class="xdoc">     *  Task.allBlockedFunc = Idle.run;
</span>   642    <span class="xdoc">     *  <b>@p</b>
</span>   643    <span class="xdoc">     *
</span>   644    <span class="xdoc">     *  Default is true.
</span>   645    <span class="xdoc">     *
</span>   646    <span class="xdoc">     *  <b>@see</b> #idleTaskStackSize
</span>   647    <span class="xdoc">     *  <b>@see</b> #idleTaskStackSection
</span>   648    <span class="xdoc">     *  <b>@see</b> #idleTaskVitalTaskFlag
</span>   649    <span class="xdoc">     *  <b>@see</b> #allBlockedFunc
</span>   650    <span class="xdoc">     */</span>
   651        <span class=key>metaonly</span> <span class=key>config</span> Bool enableIdleTask = <span class=key>true</span>;
   652    
   653        <span class="xdoc">/*! 
</span>   654    <span class="xdoc">     *  Idle task stack size in MAUs. 
</span>   655    <span class="xdoc">     *
</span>   656    <span class="xdoc">     *  Default is inherited from module config defaultStackSize.
</span>   657    <span class="xdoc">     */</span>
   658        <span class=key>metaonly</span> <span class=key>config</span> SizeT idleTaskStackSize;
   659    
   660        <span class="xdoc">/*! 
</span>   661    <span class="xdoc">     *  Idle task stack section
</span>   662    <span class="xdoc">     *
</span>   663    <span class="xdoc">     *  Default is inherited from module config defaultStackSection;
</span>   664    <span class="xdoc">     */</span>
   665        <span class=key>metaonly</span> <span class=key>config</span> String idleTaskStackSection;
   666    
   667        <span class="xdoc">/*! 
</span>   668    <span class="xdoc">     *  Idle task's vitalTaskFlag.
</span>   669    <span class="xdoc">     *  (see {<b>@link</b> #vitalTaskFlag}).
</span>   670    <span class="xdoc">     *
</span>   671    <span class="xdoc">     *  Default is true.
</span>   672    <span class="xdoc">     */</span>
   673        <span class=key>metaonly</span> <span class=key>config</span> Bool idleTaskVitalTaskFlag = <span class=key>true</span>;
   674    
   675        <span class="xdoc">/*! 
</span>   676    <span class="xdoc">     *  Function to call while all tasks are blocked.
</span>   677    <span class="xdoc">     *
</span>   678    <span class="xdoc">     *  This function will be called repeatedly while no tasks are
</span>   679    <span class="xdoc">     *  ready to run.
</span>   680    <span class="xdoc">     *
</span>   681    <span class="xdoc">     *  Ordinarily (in applications that have tasks ready to run at startup),
</span>   682    <span class="xdoc">     *  the function will run in the context of the last task to block. 
</span>   683    <span class="xdoc">     *
</span>   684    <span class="xdoc">     *  In an application where there are no tasks ready to run 
</span>   685    <span class="xdoc">     *  when BIOS_start() is called, the allBlockedFunc function is
</span>   686    <span class="xdoc">     *  called within the BIOS_start() thread which runs on the system/ISR 
</span>   687    <span class="xdoc">     *  stack.
</span>   688    <span class="xdoc">     *
</span>   689    <span class="xdoc">     *  By default, allBlockedFunc is initialized to point to an internal
</span>   690    <span class="xdoc">     *  function that simply returns.
</span>   691    <span class="xdoc">     *
</span>   692    <span class="xdoc">     *  By adding the following lines to the config script, the Idle 
</span>   693    <span class="xdoc">     *  functions will run whenever all tasks are blocked:
</span>   694    <span class="xdoc">     *
</span>   695    <span class="xdoc">     *  <b>@p(code)</b>
</span>   696    <span class="xdoc">     *  Task.enableIdleTask = false;
</span>   697    <span class="xdoc">     *  Task.allBlockedFunc = Idle.run;
</span>   698    <span class="xdoc">     *  <b>@p</b>
</span>   699    <span class="xdoc">     *
</span>   700    <span class="xdoc">     *  <b>@see</b> #enableIdleTask
</span>   701    <span class="xdoc">     *
</span>   702    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   703    <span class="xdoc">     *  The configured allBlockedFunc is designed to be called repeatedly.
</span>   704    <span class="xdoc">     *  It must return in order for the task scheduler to check if all
</span>   705    <span class="xdoc">     *  tasks are STILL blocked and if not, run the highest priority task
</span>   706    <span class="xdoc">     *  currently ready to run.
</span>   707    <span class="xdoc">     *
</span>   708    <span class="xdoc">     *  The configured allBlockedFunc function is called with interrupts
</span>   709    <span class="xdoc">     *  disabled. If your function must run with interrupts enabled, 
</span>   710    <span class="xdoc">     *  surround the body of your code with  Hwi_enable()/Hwi_restore() 
</span>   711    <span class="xdoc">     *  function calls per the following example:
</span>   712    <span class="xdoc">     *
</span>   713    <span class="xdoc">     *  <b>@p(code)</b>
</span>   714    <span class="xdoc">     *  Void yourFunc() {
</span>   715    <span class="xdoc">     *      UInt hwiKey;
</span>   716    <span class="xdoc">     *
</span>   717    <span class="xdoc">     *      hwiKey = Hwi_enable();
</span>   718    <span class="xdoc">     *
</span>   719    <span class="xdoc">     *      ...         // your code here
</span>   720    <span class="xdoc">     *
</span>   721    <span class="xdoc">     *      Hwi_restore(hwiKey);
</span>   722    <span class="xdoc">     *  }
</span>   723    <span class="xdoc">     *  <b>@p</b>
</span>   724    <span class="xdoc">     */</span>
   725        <span class=key>config</span> AllBlockedFuncPtr allBlockedFunc;
   726    
   727        <span class="xdoc">/*! 
</span>   728    <span class="xdoc">     *  Initialize stack with known value for stack checking at runtime
</span>   729    <span class="xdoc">     *  (see {<b>@link</b> #checkStackFlag}).
</span>   730    <span class="xdoc">     *
</span>   731    <span class="xdoc">     *  This is also useful for inspection of stack in debugger or core
</span>   732    <span class="xdoc">     *  dump utilities.
</span>   733    <span class="xdoc">     *  Default is true.
</span>   734    <span class="xdoc">     */</span>
   735        <span class=key>config</span> Bool initStackFlag = <span class=key>true</span>;
   736    
   737        <span class="xdoc">/*! 
</span>   738    <span class="xdoc">     *  Check 'from' and 'to' task stacks before task context switch.
</span>   739    <span class="xdoc">     *
</span>   740    <span class="xdoc">     *  The check consists of testing the top of stack value against
</span>   741    <span class="xdoc">     *  its initial value (see {<b>@link</b> #initStackFlag}). If it is no
</span>   742    <span class="xdoc">     *  longer at this value, the assumption is that the task has
</span>   743    <span class="xdoc">     *  overrun its stack. If the test fails, then the 
</span>   744    <span class="xdoc">     *  {<b>@link</b> #E_stackOverflow} error is raised.
</span>   745    <span class="xdoc">     *
</span>   746    <span class="xdoc">     *  Runtime stack checking is only performed if {<b>@link</b> #initStackFlag} is
</span>   747    <span class="xdoc">     *  also true.
</span>   748    <span class="xdoc">     *
</span>   749    <span class="xdoc">     *  Default is true.
</span>   750    <span class="xdoc">     *
</span>   751    <span class="xdoc">     *  To enable or disable full stack checking, you should set both this
</span>   752    <span class="xdoc">     *  flag and the {<b>@link</b> ti.sysbios.hal.Hwi#checkStackFlag}.
</span>   753    <span class="xdoc">     */</span>
   754        <span class=key>metaonly</span> <span class=key>config</span> Bool checkStackFlag = <span class=key>true</span>;
   755    
   756        <span class="xdoc">/*! 
</span>   757    <span class="xdoc">     *  Automatically delete terminated tasks.
</span>   758    <span class="xdoc">     *
</span>   759    <span class="xdoc">     *  If this feature is enabled, an Idle function is installed that
</span>   760    <span class="xdoc">     *  deletes dynamically created Tasks that have terminated either
</span>   761    <span class="xdoc">     *  by falling through their task function or by explicitly calling
</span>   762    <span class="xdoc">     *  Task_exit().
</span>   763    <span class="xdoc">     *
</span>   764    <span class="xdoc">     *  A list of terminated Tasks that were created dynmically is 
</span>   765    <span class="xdoc">     *  maintained internally. Each invocation of the installed Idle function
</span>   766    <span class="xdoc">     *  deletes the first Task on this list. This one-at-a-time process 
</span>   767    <span class="xdoc">     *  continues until the list is empty.
</span>   768    <span class="xdoc">     *
</span>   769    <span class="xdoc">     *  <b>@a(Note)</b>
</span>   770    <span class="xdoc">     *  This feature is disabled by default.
</span>   771    <span class="xdoc">     *
</span>   772    <span class="xdoc">     *  If this feature is enable, the user's application must not 
</span>   773    <span class="xdoc">     *  also delete terminated tasks or undefined and/or potentially 
</span>   774    <span class="xdoc">     *  catastrophic behavior will result.
</span>   775    <span class="xdoc">     */</span>
   776        <span class=key>config</span> Bool deleteTerminatedTasks = <span class=key>false</span>;
   777    
   778        <span class="xdoc">/*!
</span>   779    <span class="xdoc">     *  Const array that holds the HookSet objects.
</span>   780    <span class="xdoc">     *
</span>   781    <span class="xdoc">     *  See {<b>@link</b> #hookfunc Hook Functions} for details about HookSets. 
</span>   782    <span class="xdoc">     */</span>
   783        <span class=key>config</span> HookSet hooks[<span class=key>length</span>] = [];
   784    
   785        <span class=comment>// -------- Module Functions --------</span>
   786    
   787        <span class="xdoc">/*!
</span>   788    <span class="xdoc">     *  ======== addHookSet ========
</span>   789    <span class="xdoc">     *  addHookSet is used in a config file to add a hook set.
</span>   790    <span class="xdoc">     *
</span>   791    <span class="xdoc">     *  Configures a set of hook functions for the 
</span>   792    <span class="xdoc">     *  Task module. Each set contains these hook functions:
</span>   793    <span class="xdoc">     *
</span>   794    <span class="xdoc">     *  <b>@p(blist)</b>
</span>   795    <span class="xdoc">     *  -Register: A function called before any statically created tasks
</span>   796    <span class="xdoc">     *  are initialized at runtime.  The register hook is called at boot time
</span>   797    <span class="xdoc">     *  before main() and before interrupts are enabled.
</span>   798    <span class="xdoc">     *  -Create: A function that is called when a task is created. 
</span>   799    <span class="xdoc">     *  This includes tasks that are created statically and those
</span>   800    <span class="xdoc">     *  created dynamically using {<b>@link</b> #create} or {<b>@link</b> #construct}.
</span>   801    <span class="xdoc">     *  The create hook is called outside of a Task_disable/enable block and
</span>   802    <span class="xdoc">     *   before the task has been added to the ready list.
</span>   803    <span class="xdoc">     *  -Ready: A function that is called when a task becomes ready to run.
</span>   804    <span class="xdoc">     *   The ready hook is called from within a Task_disable/enable block with
</span>   805    <span class="xdoc">     *   interrupts enabled.
</span>   806    <span class="xdoc">     *  -Switch: A function that is called just before a task switch
</span>   807    <span class="xdoc">     *  occurs. The 'prev' and 'next' task handles are passed to the Switch
</span>   808    <span class="xdoc">     *  hook. 'prev' is set to NULL for the initial task switch that occurs
</span>   809    <span class="xdoc">     *  during SYS/BIOS startup.  The Switch hook is called from within a
</span>   810    <span class="xdoc">     *  Task_disable/enable block with interrupts enabled.
</span>   811    <span class="xdoc">     *  -Exit:  A function that is called when a task exits using
</span>   812    <span class="xdoc">     *  {<b>@link</b> #exit}.  The exit hook is passed the handle of the exiting
</span>   813    <span class="xdoc">     *  task.  The exit hook is called outside of a Task_disable/enable block
</span>   814    <span class="xdoc">     *  and before the task has been removed from the kernel lists.
</span>   815    <span class="xdoc">     *  -Delete: A function that is called when any task is deleted at
</span>   816    <span class="xdoc">     *  run-time with {<b>@link</b> #delete}.  The delete hook is called outside
</span>   817    <span class="xdoc">     *  of a Task_disable/enable block.
</span>   818    <span class="xdoc">     *  <b>@p</b>
</span>   819    <span class="xdoc">     *  Hook functions can only be configured statically.
</span>   820    <span class="xdoc">     *
</span>   821    <span class="xdoc">     *  See {<b>@link</b> #hookfunc Hook Functions} for more details. 
</span>   822    <span class="xdoc">     *
</span>   823    <span class="xdoc">     *  HookSet structure elements may be omitted, in which case those
</span>   824    <span class="xdoc">     *  elements will not exist.
</span>   825    <span class="xdoc">     *
</span>   826    <span class="xdoc">     *  For example, the following configuration code defines a HookSet:
</span>   827    <span class="xdoc">     *
</span>   828    <span class="xdoc">     *  <b>@p(code)</b>
</span>   829    <span class="xdoc">     *  // Hook Set 1 
</span>   830    <span class="xdoc">     *  Task.addHookSet({
</span>   831    <span class="xdoc">     *     registerFxn: '&amp;myRegister1',
</span>   832    <span class="xdoc">     *     createFxn:   '&amp;myCreate1',
</span>   833    <span class="xdoc">     *     readyFxn:    '&amp;myReady1',
</span>   834    <span class="xdoc">     *     switchFxn:   '&amp;mySwitch1',
</span>   835    <span class="xdoc">     *     exitFxn:     '&amp;myExit1',
</span>   836    <span class="xdoc">     *     deleteFxn:   '&amp;myDelete1'
</span>   837    <span class="xdoc">     *  });
</span>   838    <span class="xdoc">     *  <b>@p</b>
</span>   839    <span class="xdoc">     *
</span>   840    <span class="xdoc">     *  <b>@param(hook)</b>    structure of type HookSet
</span>   841    <span class="xdoc">     */</span>
   842        <span class=key>metaonly</span> Void addHookSet(HookSet hook);
   843    
   844        <span class="xdoc">/*!
</span>   845    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   846    <span class="xdoc">     *  ======== Task_startup ========
</span>   847    <span class="xdoc">     *  Start the task scheduler.
</span>   848    <span class="xdoc">     *
</span>   849    <span class="xdoc">     *  Task_startup signals the end of boot operations, enables
</span>   850    <span class="xdoc">     *  the Task scheduler and schedules the highest priority ready
</span>   851    <span class="xdoc">     *  task for execution.
</span>   852    <span class="xdoc">     *
</span>   853    <span class="xdoc">     *  Task_startup is called by BIOS_start() after Hwi_enable() 
</span>   854    <span class="xdoc">     *  and Swi_enable(). There is no return from this function as the 
</span>   855    <span class="xdoc">     *  execution thread is handed to the highest priority ready task.
</span>   856    <span class="xdoc">     */</span>
   857        @DirectCall
   858        Void startup();
   859    
   860        <span class="xdoc">/*!
</span>   861    <span class="xdoc">     *  ======== Task_disable ========
</span>   862    <span class="xdoc">     *  Disable the task scheduler.
</span>   863    <span class="xdoc">     *
</span>   864    <span class="xdoc">     *  {<b>@link</b> #disable} and {<b>@link</b> #restore} control Task scheduling.
</span>   865    <span class="xdoc">     *  {<b>@link</b> #disable} disables all other Tasks from running until
</span>   866    <span class="xdoc">     *  {<b>@link</b> #restore} is called. Hardware and Software interrupts
</span>   867    <span class="xdoc">     *  can still run.
</span>   868    <span class="xdoc">     *
</span>   869    <span class="xdoc">     *  {<b>@link</b> #disable} and {<b>@link</b> #restore} allow you to ensure that 
</span>   870    <span class="xdoc">     *  statements
</span>   871    <span class="xdoc">     *  that must be performed together during critical processing are not
</span>   872    <span class="xdoc">     *  preempted by other Tasks.
</span>   873    <span class="xdoc">     *
</span>   874    <span class="xdoc">     *  The value of the key returned is opaque to applications and is meant
</span>   875    <span class="xdoc">     *  to be passed to Task_restore().
</span>   876    <span class="xdoc">     *
</span>   877    <span class="xdoc">     *  In the following example, the critical section is
</span>   878    <span class="xdoc">     *  not preempted by any Tasks.
</span>   879    <span class="xdoc">     *
</span>   880    <span class="xdoc">     *  <b>@p(code)</b>
</span>   881    <span class="xdoc">     *  key = Task_disable();
</span>   882    <span class="xdoc">     *      `critical section`
</span>   883    <span class="xdoc">     *  Task_restore(key);
</span>   884    <span class="xdoc">     *  <b>@p</b>
</span>   885    <span class="xdoc">     *
</span>   886    <span class="xdoc">     *  You can also use {<b>@link</b> #disable} and {<b>@link</b> #restore} to 
</span>   887    <span class="xdoc">     *  create several Tasks and allow them to be invoked in 
</span>   888    <span class="xdoc">     *  priority order.
</span>   889    <span class="xdoc">     *
</span>   890    <span class="xdoc">     *  {<b>@link</b> #disable} calls can be nested.
</span>   891    <span class="xdoc">     *
</span>   892    <span class="xdoc">     *  <b>@b(returns)</b>     key for use with {<b>@link</b> #restore}
</span>   893    <span class="xdoc">     *
</span>   894    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   895    <span class="xdoc">     *  Do not call any function that can cause the current task to block 
</span>   896    <span class="xdoc">     *  within a {<b>@link</b> #disable}/{<b>@link</b> #restore} block. For example, 
</span>   897    <span class="xdoc">     *  {<b>@link</b> ti.sysbios.knl.Semaphore#pend Semaphore_pend} 
</span>   898    <span class="xdoc">     *  (if timeout is non-zero), 
</span>   899    <span class="xdoc">     *  {<b>@link</b> #sleep}, {<b>@link</b> #yield}, and Memory_alloc can all
</span>   900    <span class="xdoc">     *  cause blocking. 
</span>   901    <span class="xdoc">     */</span>
   902        @DirectCall
   903        UInt disable();
   904    
   905        <span class="xdoc">/*!
</span>   906    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   907    <span class="xdoc">     *  ======== enable ========
</span>   908    <span class="xdoc">     *  Enable the task scheduler.
</span>   909    <span class="xdoc">     *
</span>   910    <span class="xdoc">     *  {<b>@link</b> #enable} unconditionally enables the Task scheduler and
</span>   911    <span class="xdoc">     *  schedules the highest priority ready task for execution.
</span>   912    <span class="xdoc">     *
</span>   913    <span class="xdoc">     *  This function is called by {<b>@link</b> #startup} (which is called by
</span>   914    <span class="xdoc">     *  {<b>@link</b> ti.sysbios.BIOS#start BIOS_start}) to begin multi-tasking
</span>   915    <span class="xdoc">     *  operations.
</span>   916    <span class="xdoc">     */</span>
   917        @DirectCall
   918        Void enable();
   919    
   920        <span class="xdoc">/*!
</span>   921    <span class="xdoc">     *  ======== restore ========
</span>   922    <span class="xdoc">     *  Restore Task scheduling state.
</span>   923    <span class="xdoc">     *
</span>   924    <span class="xdoc">     *  {<b>@link</b> #disable} and {<b>@link</b> #restore} control Task scheduling
</span>   925    <span class="xdoc">     *  {<b>@link</b> #disable} disables all other Tasks from running until
</span>   926    <span class="xdoc">     *  {<b>@link</b> #restore} is called. Hardware and Software interrupts
</span>   927    <span class="xdoc">     *  can still run.
</span>   928    <span class="xdoc">     *
</span>   929    <span class="xdoc">     *  {<b>@link</b> #disable} and {<b>@link</b> #restore} allow you to ensure that 
</span>   930    <span class="xdoc">     *  statements
</span>   931    <span class="xdoc">     *  that must be performed together during critical processing are not
</span>   932    <span class="xdoc">     *  preempted.
</span>   933    <span class="xdoc">
</span>   934    <span class="xdoc">     *  In the following example, the critical section is not preempted
</span>   935    <span class="xdoc">     *  by any Tasks.
</span>   936    <span class="xdoc">     *
</span>   937    <span class="xdoc">     *  <b>@p(code)</b>
</span>   938    <span class="xdoc">     *  key = Task_disable();
</span>   939    <span class="xdoc">     *      `critical section`
</span>   940    <span class="xdoc">     *  Task_restore(key);
</span>   941    <span class="xdoc">     *  <b>@p</b>
</span>   942    <span class="xdoc">     *
</span>   943    <span class="xdoc">     *  You can also use {<b>@link</b> #disable} and {<b>@link</b> #restore} to create 
</span>   944    <span class="xdoc">     *  several Tasks and allow them to be performed in priority order.
</span>   945    <span class="xdoc">     *
</span>   946    <span class="xdoc">     *  {<b>@link</b> #disable} calls can be nested.
</span>   947    <span class="xdoc">     *
</span>   948    <span class="xdoc">     *  {<b>@link</b> #restore} returns with interrupts enabled if the key unlocks
</span>   949    <span class="xdoc">     *  the scheduler
</span>   950    <span class="xdoc">     *
</span>   951    <span class="xdoc">     *  <b>@param(key)</b>     key to restore previous Task scheduler state
</span>   952    <span class="xdoc">     *
</span>   953    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   954    <span class="xdoc">     *  Do not call any function that can cause the current task to block 
</span>   955    <span class="xdoc">     *  within a {<b>@link</b> #disable}/{<b>@link</b> #restore} block. For example, 
</span>   956    <span class="xdoc">     *  {<b>@link</b> ti.sysbios.knl.Semaphore#pend Semaphore_pend()} 
</span>   957    <span class="xdoc">     *  (if timeout is non-zero), 
</span>   958    <span class="xdoc">     *  {<b>@link</b> #sleep}, {<b>@link</b> #yield}, and Memory_alloc can all
</span>   959    <span class="xdoc">     *  cause blocking. 
</span>   960    <span class="xdoc">     *
</span>   961    <span class="xdoc">     *  {<b>@link</b> #restore} internally calls Hwi_enable() if the key passed
</span>   962    <span class="xdoc">     *  to it results in the unlocking of the Task scheduler (ie if this
</span>   963    <span class="xdoc">     *  is root Task_disable/Task_restore pair).
</span>   964    <span class="xdoc">     */</span>
   965        @DirectCall
   966        Void restore(UInt key);
   967    
   968        <span class="xdoc">/*!
</span>   969    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   970    <span class="xdoc">     *  ======== restoreHwi ========
</span>   971    <span class="xdoc">     *  Restore Task scheduling state.
</span>   972    <span class="xdoc">     *  Used by dispatcher. Does not re-enable Ints.
</span>   973    <span class="xdoc">     */</span>
   974        @DirectCall
   975        Void restoreHwi(UInt key);
   976    
   977        <span class="xdoc">/*!
</span>   978    <span class="xdoc">     *  ======== self ========
</span>   979    <span class="xdoc">     *  Returns a handle to the currently executing Task object.
</span>   980    <span class="xdoc">     *
</span>   981    <span class="xdoc">     *  Task_self returns the object handle for the currently executing task. 
</span>   982    <span class="xdoc">     *  This function is useful when inspecting the object or when the current 
</span>   983    <span class="xdoc">     *  task changes its own priority through {<b>@link</b> #setPri}.
</span>   984    <span class="xdoc">     *  
</span>   985    <span class="xdoc">     *  No task switch occurs when calling Task_self.
</span>   986    <span class="xdoc">     *  
</span>   987    <span class="xdoc">     *  Task_self will return NULL until Tasking is initiated at the end of 
</span>   988    <span class="xdoc">     *  BIOS_start().
</span>   989    <span class="xdoc">     *
</span>   990    <span class="xdoc">     *  <b>@b(returns)</b>     address of currently executing task object
</span>   991    <span class="xdoc">     */</span>
   992        @DirectCall
   993        Handle self();
   994    
   995        <span class="xdoc">/*!
</span>   996    <span class="xdoc">     *  ======== selfMacro ========
</span>   997    <span class="xdoc">     *  Returns a handle to the currently executing Task object.
</span>   998    <span class="xdoc">     *
</span>   999    <span class="xdoc">     *  Task_selfMacro is identical to {<b>@link</b> #self} but is implemented as
</span>  1000    <span class="xdoc">     *  and inline macro.
</span>  1001    <span class="xdoc">     *
</span>  1002    <span class="xdoc">     *  <b>@b(returns)</b>     address of currently executing task object
</span>  1003    <span class="xdoc">     */</span>
  1004        @Macro
  1005        Handle selfMacro();
  1006    
  1007        <span class="xdoc">/*!
</span>  1008    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1009    <span class="xdoc">     *  ======== checkStacks ========
</span>  1010    <span class="xdoc">     *  Check for stack overflow.
</span>  1011    <span class="xdoc">     *
</span>  1012    <span class="xdoc">     *  This function is usually called by the {<b>@link</b> #HookSet} switchFxn to 
</span>  1013    <span class="xdoc">     *  make sure task stacks are valid before performing the context 
</span>  1014    <span class="xdoc">     *  switch.
</span>  1015    <span class="xdoc">     *
</span>  1016    <span class="xdoc">     *  If a stack overflow is detected on either the oldTask or the
</span>  1017    <span class="xdoc">     *  newTask, a {<b>@link</b> #E_stackOverflow} Error is raised and the system 
</span>  1018    <span class="xdoc">     *  exited.
</span>  1019    <span class="xdoc">     *
</span>  1020    <span class="xdoc">     *  In order to work properly, {<b>@link</b> #checkStacks} requires that the
</span>  1021    <span class="xdoc">     *  {<b>@link</b> #initStackFlag} set to true, which it is by default.
</span>  1022    <span class="xdoc">     *
</span>  1023    <span class="xdoc">     *  You can call {<b>@link</b> #checkStacks} directly from your application. 
</span>  1024    <span class="xdoc">     *  For example, you can check the current task's stack integrity 
</span>  1025    <span class="xdoc">     *  at any time with a call like the following:
</span>  1026    <span class="xdoc">     *
</span>  1027    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1028    <span class="xdoc">     *  Task_checkStacks(Task_self(), Task_self());
</span>  1029    <span class="xdoc">     *  <b>@p</b>
</span>  1030    <span class="xdoc">     *
</span>  1031    <span class="xdoc">     *  <b>@param(oldTask)</b>  leaving Task Object Ptr
</span>  1032    <span class="xdoc">     *  <b>@param(newTask)</b>  entering Task Object Ptr
</span>  1033    <span class="xdoc">     */</span>
  1034        @DirectCall
  1035        Void checkStacks(Handle oldTask, Handle newTask);
  1036    
  1037        <span class="xdoc">/*!
</span>  1038    <span class="xdoc">     *  ======== exit ========
</span>  1039    <span class="xdoc">     *  Terminate execution of the current task.
</span>  1040    <span class="xdoc">     *
</span>  1041    <span class="xdoc">     *  Task_exit terminates execution of the current task, changing its mode
</span>  1042    <span class="xdoc">     *  from {<b>@link</b> #Mode_RUNNING} to {<b>@link</b> #Mode_TERMINATED}. If all tasks 
</span>  1043    <span class="xdoc">     *  have been terminated, or if all remaining tasks have their 
</span>  1044    <span class="xdoc">     *  vitalTaskFlag attribute set to FALSE, then SYS/BIOS terminates the 
</span>  1045    <span class="xdoc">     *  program as a whole by calling the function System_exit with a status 
</span>  1046    <span class="xdoc">     *  code of 0.
</span>  1047    <span class="xdoc">     * 
</span>  1048    <span class="xdoc">     *  Task_exit is automatically called whenever a task returns from its 
</span>  1049    <span class="xdoc">     *  top-level function.
</span>  1050    <span class="xdoc">     * 
</span>  1051    <span class="xdoc">     *  Exit Hooks (see exitFxn in {<b>@link</b> #HookSet}) can be used to provide 
</span>  1052    <span class="xdoc">     *  functions that run whenever a task is terminated. The exitFxn Hooks 
</span>  1053    <span class="xdoc">     *  are called before the task has been blocked and marked 
</span>  1054    <span class="xdoc">     *  {<b>@link</b> #Mode_TERMINATED}.
</span>  1055    <span class="xdoc">     *  See {<b>@link</b> #hookfunc Hook Functions} for more information. 
</span>  1056    <span class="xdoc">     *
</span>  1057    <span class="xdoc">     *  Any SYS/BIOS function can be called from an Exit Hook function. 
</span>  1058    <span class="xdoc">     *
</span>  1059    <span class="xdoc">     *  Calling {<b>@link</b> #self} within an Exit function returns the task
</span>  1060    <span class="xdoc">     *  being exited. Your Exit function declaration should be similar to 
</span>  1061    <span class="xdoc">     *  the following:
</span>  1062    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1063    <span class="xdoc">     *  Void myExitFxn(Void);
</span>  1064    <span class="xdoc">     *  <b>@p</b>
</span>  1065    <span class="xdoc">     * 
</span>  1066    <span class="xdoc">     *  A task switch occurs when calling Task_exit unless the program as a
</span>  1067    <span class="xdoc">     *  whole is terminated
</span>  1068    <span class="xdoc">     *
</span>  1069    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1070    <span class="xdoc">     *  Task_exit cannot be called from a Swi or Hwi.
</span>  1071    <span class="xdoc">     *
</span>  1072    <span class="xdoc">     *  Task_exit cannot be called from the program's main() function.
</span>  1073    <span class="xdoc">     */</span>
  1074        @DirectCall
  1075        Void exit();
  1076    
  1077        <span class="xdoc">/*!
</span>  1078    <span class="xdoc">     *  ======== sleep ========
</span>  1079    <span class="xdoc">     *  Delay execution of the current task.
</span>  1080    <span class="xdoc">     *
</span>  1081    <span class="xdoc">     *  Task_sleep changes the current task's mode from {<b>@link</b> #Mode_RUNNING} 
</span>  1082    <span class="xdoc">     *  to {<b>@link</b> #Mode_BLOCKED}, and delays its execution for nticks 
</span>  1083    <span class="xdoc">     *  increments of the {<b>@link</b> Clock system clock}. The actual time
</span>  1084    <span class="xdoc">     *  delayed can be up to 1 system clock tick less than nticks due to
</span>  1085    <span class="xdoc">     *  granularity in system timekeeping and the time elapsed per
</span>  1086    <span class="xdoc">     *  tick is determined by {<b>@link</b> Clock#tickPeriod Clock_tickPeriod}.
</span>  1087    <span class="xdoc">     *  
</span>  1088    <span class="xdoc">     *  After the specified period of time has elapsed, the task reverts to 
</span>  1089    <span class="xdoc">     *  the {<b>@link</b> #Mode_READY} mode and is scheduled for execution.
</span>  1090    <span class="xdoc">     *  
</span>  1091    <span class="xdoc">     *  A task switch always occurs when calling Task_sleep if nticks &gt; 0.
</span>  1092    <span class="xdoc">     *
</span>  1093    <span class="xdoc">     *  <b>@param(nticks)</b>  number of system clock ticks to sleep
</span>  1094    <span class="xdoc">     *
</span>  1095    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1096    <span class="xdoc">     *  Task_sleep cannot be called from a Swi or Hwi, or within a
</span>  1097    <span class="xdoc">     *  {<b>@link</b> #disable} / {<b>@link</b> #restore} block.
</span>  1098    <span class="xdoc">     *
</span>  1099    <span class="xdoc">     *  Task_sleep cannot be called from the program's main() function.
</span>  1100    <span class="xdoc">     *
</span>  1101    <span class="xdoc">     *  Task_sleep should not be called from within an Idle function. Doing 
</span>  1102    <span class="xdoc">     *  so prevents analysis tools from gathering run-time information.
</span>  1103    <span class="xdoc">     *
</span>  1104    <span class="xdoc">     *  nticks cannot be {<b>@link</b> ti.sysbios.BIOS#WAIT_FOREVER BIOS_WAIT_FOREVER}.
</span>  1105    <span class="xdoc">     */</span>
  1106        @DirectCall
  1107        Void sleep(UInt nticks);
  1108    
  1109        <span class="xdoc">/*!
</span>  1110    <span class="xdoc">     *  ======== yield ========
</span>  1111    <span class="xdoc">     *  Yield processor to equal priority task.
</span>  1112    <span class="xdoc">     *
</span>  1113    <span class="xdoc">     *  Task_yield yields the processor to another task of equal priority.
</span>  1114    <span class="xdoc">     *  
</span>  1115    <span class="xdoc">     *  A task switch occurs when you call Task_yield if there is an equal 
</span>  1116    <span class="xdoc">     *  priority task ready to run.
</span>  1117    <span class="xdoc">     *  
</span>  1118    <span class="xdoc">     *  Tasks of higher priority preempt the currently running task without 
</span>  1119    <span class="xdoc">     *  the need for a call to Task_yield. If only lower-priority tasks are 
</span>  1120    <span class="xdoc">     *  ready to run when you call Task_yield, the current task continues to 
</span>  1121    <span class="xdoc">     *  run. Control does not pass to a lower-priority task.
</span>  1122    <span class="xdoc">     *
</span>  1123    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1124    <span class="xdoc">     *  When called within an Hwi, the code sequence calling Task_yield
</span>  1125    <span class="xdoc">     *  must be invoked by the Hwi dispatcher.
</span>  1126    <span class="xdoc">     *
</span>  1127    <span class="xdoc">     *  Task_yield cannot be called from the program's main() function.
</span>  1128    <span class="xdoc">     */</span>
  1129        @DirectCall
  1130        Void yield();
  1131    
  1132        <span class="xdoc">/*!
</span>  1133    <span class="xdoc">     *  ======== getIdleTask ========
</span>  1134    <span class="xdoc">     *  returns a handle to idle task object
</span>  1135    <span class="xdoc">     */</span>
  1136        @DirectCall
  1137        Handle getIdleTask();
  1138        
  1139        <span class="xdoc">/*!
</span>  1140    <span class="xdoc">     *  ======== getNickName ========
</span>  1141    <span class="xdoc">     *  
</span>  1142    <span class="xdoc">     */</span>
  1143        <span class=key>metaonly</span> String getNickName(Any tskView);
  1144    
  1145    <span class=key>instance</span>:
  1146    
  1147        <span class="xdoc">/*!
</span>  1148    <span class="xdoc">     *  ======== create ========
</span>  1149    <span class="xdoc">     *  Create a Task.
</span>  1150    <span class="xdoc">     *
</span>  1151    <span class="xdoc">     *  Task_create creates a new task object. If successful, Task_create
</span>  1152    <span class="xdoc">     *  returns the handle of the new task object. If unsuccessful, 
</span>  1153    <span class="xdoc">     *  Task_create returns NULL unless it aborts.
</span>  1154    <span class="xdoc">     *
</span>  1155    <span class="xdoc">     *  The fxn parameter uses the {<b>@link</b> #FuncPtr} type to pass a pointer to 
</span>  1156    <span class="xdoc">     *  the function the Task object should run. For example, if myFxn is a 
</span>  1157    <span class="xdoc">     *  function in your program, your C code can create a Task object 
</span>  1158    <span class="xdoc">     *  to call that 
</span>  1159    <span class="xdoc">     *  function as follows: 
</span>  1160    <span class="xdoc">     *  
</span>  1161    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1162    <span class="xdoc">     *  Task_Params taskParams;
</span>  1163    <span class="xdoc">     *  
</span>  1164    <span class="xdoc">     *  // Create task with priority 15 
</span>  1165    <span class="xdoc">     *  Task_Params_init(&amp;taskParams);
</span>  1166    <span class="xdoc">     *  taskParams.stackSize = 512;
</span>  1167    <span class="xdoc">     *  taskParams.priority = 15;
</span>  1168    <span class="xdoc">     *  Task_create((Task_FuncPtr)myFxn, &amp;taskParams, &amp;eb);
</span>  1169    <span class="xdoc">     *  <b>@p</b>
</span>  1170    <span class="xdoc">     *
</span>  1171    <span class="xdoc">     *  The following statements statically create a task in the 
</span>  1172    <span class="xdoc">     *  configuration file: 
</span>  1173    <span class="xdoc">     *  
</span>  1174    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1175    <span class="xdoc">     *  var params = new Task.Params;
</span>  1176    <span class="xdoc">     *  params.instance.name = "tsk0";
</span>  1177    <span class="xdoc">     *  params.arg0 = 1;
</span>  1178    <span class="xdoc">     *  params.arg1 = 2;
</span>  1179    <span class="xdoc">     *  params.priority = 1;
</span>  1180    <span class="xdoc">     *  Task.create('&amp;tsk0_func', params);
</span>  1181    <span class="xdoc">     *  <b>@p</b>
</span>  1182    <span class="xdoc">     *
</span>  1183    <span class="xdoc">     *  If NULL is passed instead of a pointer to an actual Task_Params 
</span>  1184    <span class="xdoc">     *  struct, a
</span>  1185    <span class="xdoc">     *  default set of parameters is used. The "eb" is an error block that 
</span>  1186    <span class="xdoc">     *  you can use
</span>  1187    <span class="xdoc">     *  to handle errors that may occur during Task object creation.
</span>  1188    <span class="xdoc">     *
</span>  1189    <span class="xdoc">     *  The newly created task is placed in {<b>@link</b> #Mode_READY} mode, and is 
</span>  1190    <span class="xdoc">     *  scheduled to begin concurrent execution of the following function 
</span>  1191    <span class="xdoc">     *  call:
</span>  1192    <span class="xdoc">     *
</span>  1193    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1194    <span class="xdoc">     *  (*fxn)(arg1, arg2);
</span>  1195    <span class="xdoc">     *  <b>@p</b>
</span>  1196    <span class="xdoc">     *
</span>  1197    <span class="xdoc">     *  As a result of being made ready to run, the task runs any
</span>  1198    <span class="xdoc">     *  application-wide Ready functions that have been specified.
</span>  1199    <span class="xdoc">     *
</span>  1200    <span class="xdoc">     *  Task_exit is automatically called if and when the task returns 
</span>  1201    <span class="xdoc">     *  from fxn. 
</span>  1202    <span class="xdoc">     *  
</span>  1203    <span class="xdoc">     *  <b>@p(html)</b>
</span>  1204    <span class="xdoc">     *  &lt;B&gt;Create Hook Functions&lt;/B&gt;
</span>  1205    <span class="xdoc">     *  <b>@p</b>
</span>  1206    <span class="xdoc">     *  
</span>  1207    <span class="xdoc">     *  You can specify application-wide Create hook functions in your config
</span>  1208    <span class="xdoc">     *  file that run whenever a task is created. This includes tasks that 
</span>  1209    <span class="xdoc">     *  are created statically and those created dynamically using 
</span>  1210    <span class="xdoc">     *  Task_create.
</span>  1211    <span class="xdoc">     *
</span>  1212    <span class="xdoc">     *  For Task objects created statically, Create functions are called
</span>  1213    <span class="xdoc">     *  during the Task module initialization phase of the program startup 
</span>  1214    <span class="xdoc">     *  process prior to main().
</span>  1215    <span class="xdoc">     *
</span>  1216    <span class="xdoc">     *  For Task objects created dynamically, Create functions 
</span>  1217    <span class="xdoc">     *  are called after the task handle has been initialized but before the 
</span>  1218    <span class="xdoc">     *  task has been placed on its ready queue.
</span>  1219    <span class="xdoc">     *
</span>  1220    <span class="xdoc">     *  Any SYS/BIOS function can be called from Create functions.
</span>  1221    <span class="xdoc">     *  SYS/BIOS passes the task handle of the task being created to each of 
</span>  1222    <span class="xdoc">     *  the Create functions. 
</span>  1223    <span class="xdoc">     *
</span>  1224    <span class="xdoc">     *  All Create function declarations should be similar to this:
</span>  1225    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1226    <span class="xdoc">     *  Void myCreateFxn(Task_Handle task);
</span>  1227    <span class="xdoc">     *  <b>@p</b>
</span>  1228    <span class="xdoc">     *
</span>  1229    <span class="xdoc">     *  <b>@param(fxn)</b>     Task Function
</span>  1230    <span class="xdoc">     *  
</span>  1231    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1232    <span class="xdoc">     *  <b>@p(blist)</b>
</span>  1233    <span class="xdoc">     *  - The fxn parameter and the name attribute cannot be NULL.
</span>  1234    <span class="xdoc">     *  - The priority attribute must be less than or equal to 
</span>  1235    <span class="xdoc">     *  ({<b>@link</b> #numPriorities} - 1) and greater than or equal to one (1)
</span>  1236    <span class="xdoc">     *  (priority 0 is owned by the Idle task). 
</span>  1237    <span class="xdoc">     *  - The priority can be set to -1 for tasks that will not execute
</span>  1238    <span class="xdoc">     *  until another task changes the priority to a positive value.
</span>  1239    <span class="xdoc">     *  - The stackHeap attribute must identify a valid memory Heap.
</span>  1240    <span class="xdoc">     *  <b>@p</b>
</span>  1241    <span class="xdoc">     */</span>
  1242        @DirectCall
  1243        create(FuncPtr fxn);
  1244    
  1245        <span class=comment>// -------- Handle Parameters --------</span>
  1246    
  1247        <span class="xdoc">/*! Task function argument. Default is 0 */</span>
  1248        <span class=key>config</span> UArg arg0 = 0;
  1249    
  1250        <span class="xdoc">/*! Task function argument. Default is 0 */</span>
  1251        <span class=key>config</span> UArg arg1 = 0;
  1252    
  1253        <span class="xdoc">/*!
</span>  1254    <span class="xdoc">     *  Task priority (0 to numPriorities-1 or -1).
</span>  1255    <span class="xdoc">     *  Default is 1.
</span>  1256    <span class="xdoc">     */</span>
  1257        <span class=key>config</span> Int priority = 1;
  1258    
  1259        <span class="xdoc">/*!
</span>  1260    <span class="xdoc">     *  Task stack pointer. Default = null.
</span>  1261    <span class="xdoc">     *
</span>  1262    <span class="xdoc">     *  Null indicates that the stack is to be allocated by create().
</span>  1263    <span class="xdoc">     *
</span>  1264    <span class="xdoc">     *  Example: To statically initialize "tsk0"'s stack to a literal
</span>  1265    <span class="xdoc">     *  address, use the following syntax:
</span>  1266    <span class="xdoc">     *
</span>  1267    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1268    <span class="xdoc">     *      Program.global.tsk0.stack = $addr(literal);
</span>  1269    <span class="xdoc">     *  <b>@p</b>
</span>  1270    <span class="xdoc">     *
</span>  1271    <span class="xdoc">     */</span>
  1272        <span class=key>config</span> Ptr stack = <span class=key>null</span>;
  1273    
  1274        <span class="xdoc">/*! 
</span>  1275    <span class="xdoc">     *  Task stack size in MAUs. 
</span>  1276    <span class="xdoc">     *
</span>  1277    <span class="xdoc">     *  The default value of 0 means that the module config 
</span>  1278    <span class="xdoc">     *  {<b>@link</b> #defaultStackSize} is used.
</span>  1279    <span class="xdoc">     */</span>
  1280        <span class=key>config</span> SizeT stackSize = 0;
  1281    
  1282        <span class="xdoc">/*!
</span>  1283    <span class="xdoc">     *  Mem section used for statically created task stacks.
</span>  1284    <span class="xdoc">     *
</span>  1285    <span class="xdoc">     *  Default is inherited from module config defaultStackSection.
</span>  1286    <span class="xdoc">     */</span>
  1287        <span class=key>metaonly</span> <span class=key>config</span> String stackSection;
  1288    
  1289        <span class="xdoc">/*!
</span>  1290    <span class="xdoc">     *  Mem heap used for dynamically created task stack.
</span>  1291    <span class="xdoc">     *
</span>  1292    <span class="xdoc">     *  The default value of NULL means that the module config 
</span>  1293    <span class="xdoc">     *  {<b>@link</b> #defaultStackHeap} is used.
</span>  1294    <span class="xdoc">     */</span>
  1295        <span class=key>config</span> IHeap.Handle stackHeap = <span class=key>null</span>;
  1296    
  1297        <span class="xdoc">/*! Environment data struct. */</span>
  1298        <span class=key>config</span> Ptr env = <span class=key>null</span>;
  1299    
  1300        <span class="xdoc">/*!
</span>  1301    <span class="xdoc">     *  Exit system immediately when the last task with this
</span>  1302    <span class="xdoc">     *  flag set to TRUE has terminated. 
</span>  1303    <span class="xdoc">     *
</span>  1304    <span class="xdoc">     *  Default is true.
</span>  1305    <span class="xdoc">     */</span>
  1306        <span class=key>config</span> Bool vitalTaskFlag = <span class=key>true</span>;
  1307    
  1308        <span class=comment>// -------- Handle Functions --------</span>
  1309    
  1310        <span class="xdoc">/*!
</span>  1311    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1312    <span class="xdoc">     *  ======== getArg0 ========
</span>  1313    <span class="xdoc">     *  Returns arg0 passed via params to create.
</span>  1314    <span class="xdoc">     *
</span>  1315    <span class="xdoc">     *  <b>@b(returns)</b>     task's arg0
</span>  1316    <span class="xdoc">     */</span>
  1317        @DirectCall
  1318        UArg getArg0();
  1319    
  1320        <span class="xdoc">/*!
</span>  1321    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1322    <span class="xdoc">     *  ======== getArg1 ========
</span>  1323    <span class="xdoc">     *  Returns arg1 passed via params to create.
</span>  1324    <span class="xdoc">     *
</span>  1325    <span class="xdoc">     *  <b>@b(returns)</b>     task's arg1
</span>  1326    <span class="xdoc">     */</span>
  1327        @DirectCall
  1328        UArg getArg1();
  1329    
  1330        <span class="xdoc">/*!
</span>  1331    <span class="xdoc">     *  ======== getEnv ========
</span>  1332    <span class="xdoc">     *  Get task environment pointer.
</span>  1333    <span class="xdoc">     *
</span>  1334    <span class="xdoc">     *  Task_getEnv returns the environment pointer of the specified task. The
</span>  1335    <span class="xdoc">     *  environment pointer references an arbitrary application-defined data 
</span>  1336    <span class="xdoc">     *  structure.
</span>  1337    <span class="xdoc">     *  
</span>  1338    <span class="xdoc">     *  If your program uses multiple hook sets, {<b>@link</b> #getHookContext} 
</span>  1339    <span class="xdoc">     *  allows you to get environment pointers you have set for a particular 
</span>  1340    <span class="xdoc">     *  hook set and Task object combination.
</span>  1341    <span class="xdoc">     *
</span>  1342    <span class="xdoc">     *  <b>@b(returns)</b>     task environment pointer
</span>  1343    <span class="xdoc">     */</span>
  1344        @DirectCall
  1345        Ptr getEnv();
  1346    
  1347        <span class="xdoc">/*!
</span>  1348    <span class="xdoc">     *  ======== getHookContext ========
</span>  1349    <span class="xdoc">     *  Get hook set's context for a task.
</span>  1350    <span class="xdoc">     *
</span>  1351    <span class="xdoc">     *  For example, this C code gets the HookContext, prints it,
</span>  1352    <span class="xdoc">     *  and sets a new value for the HookContext.
</span>  1353    <span class="xdoc">     *
</span>  1354    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1355    <span class="xdoc">     *  Ptr pEnv;
</span>  1356    <span class="xdoc">     *  Task_Handle myTask;
</span>  1357    <span class="xdoc">     *  Int myHookSetId1;
</span>  1358    <span class="xdoc">     * 
</span>  1359    <span class="xdoc">     *  pEnv = Task_getHookContext(task, myHookSetId1);
</span>  1360    <span class="xdoc">     * 
</span>  1361    <span class="xdoc">     *  System_printf("myEnd1: pEnv = 0x%lx, time = %ld\n", 
</span>  1362    <span class="xdoc">     *                (ULong)pEnv, (ULong)Timestamp_get32());
</span>  1363    <span class="xdoc">     * 
</span>  1364    <span class="xdoc">     *  Task_setHookContext(task, myHookSetId1, (Ptr)0xc0de1);
</span>  1365    <span class="xdoc">     *  <b>@p</b>
</span>  1366    <span class="xdoc">     *
</span>  1367    <span class="xdoc">     *  See {<b>@link</b> #hookfunc Hook Functions} for more details. 
</span>  1368    <span class="xdoc">     *
</span>  1369    <span class="xdoc">     *  <b>@param(id)</b>      hook set ID
</span>  1370    <span class="xdoc">     *  <b>@b(returns)</b>     hook set context for task
</span>  1371    <span class="xdoc">     */</span>
  1372        @DirectCall
  1373        Ptr getHookContext(Int id);
  1374    
  1375        <span class="xdoc">/*!
</span>  1376    <span class="xdoc">     *  ======== getPri ========
</span>  1377    <span class="xdoc">     *  Get task priority.
</span>  1378    <span class="xdoc">     *
</span>  1379    <span class="xdoc">     *  Task_getPri returns the priority of the referenced task.
</span>  1380    <span class="xdoc">     *
</span>  1381    <span class="xdoc">     *  <b>@b(returns)</b>     task priority
</span>  1382    <span class="xdoc">     */</span>
  1383        @DirectCall
  1384        Int getPri();
  1385    
  1386        <span class="xdoc">/*!
</span>  1387    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1388    <span class="xdoc">     *  ======== setArg0 ========
</span>  1389    <span class="xdoc">     *  Set arg0 (used primarily for legacy support)
</span>  1390    <span class="xdoc">     */</span>
  1391        @DirectCall
  1392        Void setArg0(UArg arg);
  1393    
  1394        <span class="xdoc">/*!
</span>  1395    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1396    <span class="xdoc">     *  ======== setArg1 ========
</span>  1397    <span class="xdoc">     *  Set arg1 (used primarily for legacy support)
</span>  1398    <span class="xdoc">     */</span>
  1399        @DirectCall
  1400        Void setArg1(UArg arg);
  1401    
  1402        <span class="xdoc">/*!
</span>  1403    <span class="xdoc">     *  ======== setEnv ========
</span>  1404    <span class="xdoc">     *  Set task environment.
</span>  1405    <span class="xdoc">     *
</span>  1406    <span class="xdoc">     *  Task_setEnv sets the task environment pointer to env. The
</span>  1407    <span class="xdoc">     *  environment pointer references an arbitrary application-defined
</span>  1408    <span class="xdoc">     *  data structure.
</span>  1409    <span class="xdoc">     *
</span>  1410    <span class="xdoc">     *  If your program uses multiple hook sets, {<b>@link</b> #setHookContext} 
</span>  1411    <span class="xdoc">     *  allows you to set environment pointers for any
</span>  1412    <span class="xdoc">     *  hook set and Task object combination.
</span>  1413    <span class="xdoc">     *
</span>  1414    <span class="xdoc">     *  <b>@param(env)</b>     task environment pointer
</span>  1415    <span class="xdoc">     */</span>
  1416        @DirectCall
  1417        Void setEnv(Ptr env);
  1418    
  1419        <span class="xdoc">/*!
</span>  1420    <span class="xdoc">     *  ======== setHookContext ========
</span>  1421    <span class="xdoc">     *  Set hook instance's context for a task.
</span>  1422    <span class="xdoc">     *
</span>  1423    <span class="xdoc">     *  For example, this C code gets the HookContext, prints it,
</span>  1424    <span class="xdoc">     *  and sets a new value for the HookContext.
</span>  1425    <span class="xdoc">     *
</span>  1426    <span class="xdoc">     *  <b>@p(code)</b>
</span>  1427    <span class="xdoc">     *  Ptr pEnv;
</span>  1428    <span class="xdoc">     *  Task_Handle myTask;
</span>  1429    <span class="xdoc">     *  Int myHookSetId1;
</span>  1430    <span class="xdoc">     * 
</span>  1431    <span class="xdoc">     *  pEnv = Task_getHookContext(task, myHookSetId1);
</span>  1432    <span class="xdoc">     * 
</span>  1433    <span class="xdoc">     *  System_printf("myEnd1: pEnv = 0x%lx, time = %ld\n", 
</span>  1434    <span class="xdoc">     *                (ULong)pEnv, (ULong)Timestamp_get32());
</span>  1435    <span class="xdoc">     * 
</span>  1436    <span class="xdoc">     *  Task_setHookContext(task, myHookSetId1, (Ptr)0xc0de1);
</span>  1437    <span class="xdoc">     *  <b>@p</b>
</span>  1438    <span class="xdoc">     *
</span>  1439    <span class="xdoc">     *  See {<b>@link</b> #hookfunc Hook Functions} for more details. 
</span>  1440    <span class="xdoc">     *
</span>  1441    <span class="xdoc">     *  <b>@param(id)</b>              hook set ID
</span>  1442    <span class="xdoc">     *  <b>@param(hookContext)</b>     value to write to context
</span>  1443    <span class="xdoc">     */</span>
  1444        @DirectCall
  1445        Void setHookContext(Int id, Ptr hookContext);
  1446    
  1447        <span class="xdoc">/*!
</span>  1448    <span class="xdoc">     *  ======== setPri ========
</span>  1449    <span class="xdoc">     *  Set a task's priority
</span>  1450    <span class="xdoc">     *
</span>  1451    <span class="xdoc">     *  Task_setpri sets the execution priority of task to newpri, and returns
</span>  1452    <span class="xdoc">     *  that task's old priority value. Raising or lowering a task's priority
</span>  1453    <span class="xdoc">     *  does not necessarily force preemption and re-scheduling of the caller:
</span>  1454    <span class="xdoc">     *  tasks in the {<b>@link</b> #Mode_BLOCKED} mode remain suspended despite a
</span>  1455    <span class="xdoc">     *  change in priority; and tasks in the {<b>@link</b> #Mode_READY} mode gain
</span>  1456    <span class="xdoc">     *  control only if their new priority is greater than that of the
</span>  1457    <span class="xdoc">     *  currently executing task.
</span>  1458    <span class="xdoc">     *  
</span>  1459    <span class="xdoc">     *  newpri should be set to a value greater than or equal to 1 and
</span>  1460    <span class="xdoc">     *  less than or equal to ({<b>@link</b> #numPriorities} - 1).  newpri can also
</span>  1461    <span class="xdoc">     *  be set to -1 which puts the the task into the INACTIVE state and the
</span>  1462    <span class="xdoc">     *  task will not run until its priority is raised at a later time by
</span>  1463    <span class="xdoc">     *  another task.  Priority 0 is reserved for the idle task.
</span>  1464    <span class="xdoc">     *  If newpri equals ({<b>@link</b> #numPriorities} - 1), execution of the task
</span>  1465    <span class="xdoc">     *  effectively locks out all other program activity, except for the
</span>  1466    <span class="xdoc">     *  handling of interrupts.
</span>  1467    <span class="xdoc">     *  
</span>  1468    <span class="xdoc">     *  The current task can change its own priority (and possibly preempt its
</span>  1469    <span class="xdoc">     *  execution) by passing the output of {<b>@link</b> #self} as the value of the 
</span>  1470    <span class="xdoc">     *  task parameter.
</span>  1471    <span class="xdoc">     *  
</span>  1472    <span class="xdoc">     *  A context switch occurs when calling Task_setpri if a currently 
</span>  1473    <span class="xdoc">     *  running task priority is set lower than the priority of another 
</span>  1474    <span class="xdoc">     *  currently ready task, or if another ready task is made to have a
</span>  1475    <span class="xdoc">     *  higher priority than the currently running task.
</span>  1476    <span class="xdoc">     *
</span>  1477    <span class="xdoc">     *  Task_setpri can be used for mutual exclusion.
</span>  1478    <span class="xdoc">     *
</span>  1479    <span class="xdoc">     *  If a task's new priority is different than its previous priority, 
</span>  1480    <span class="xdoc">     *  then its relative placement in its new ready task priority 
</span>  1481    <span class="xdoc">     *  queue can be different than the one it was removed from. This can 
</span>  1482    <span class="xdoc">     *  effect the relative order in which it becomes the running task.
</span>  1483    <span class="xdoc">     *
</span>  1484    <span class="xdoc">     *  The effected task is placed at the head of its new priority queue
</span>  1485    <span class="xdoc">     *  if it is the currently running task. Otherwise it is placed at
</span>  1486    <span class="xdoc">     *  at the end of its new task priority queue.
</span>  1487    <span class="xdoc">     *
</span>  1488    <span class="xdoc">     *  <b>@param(newpri)</b> task's new priority
</span>  1489    <span class="xdoc">     *  <b>@b(returns)</b>    task's old priority
</span>  1490    <span class="xdoc">     *
</span>  1491    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1492    <span class="xdoc">     *  newpri must be a value between 1 and ({<b>@link</b> #numPriorities} - 1) or -1.
</span>  1493    <span class="xdoc">     *
</span>  1494    <span class="xdoc">     *  The task cannot be in the {<b>@link</b> #Mode_TERMINATED} mode.
</span>  1495    <span class="xdoc">     *
</span>  1496    <span class="xdoc">     *  The new priority should not be zero (0). This priority level is 
</span>  1497    <span class="xdoc">     *  reserved for the Idle task.
</span>  1498    <span class="xdoc">     */</span>
  1499        @DirectCall
  1500        UInt setPri(Int newpri);
  1501    
  1502        <span class="xdoc">/*!
</span>  1503    <span class="xdoc">     *  ======== stat ========
</span>  1504    <span class="xdoc">     *  Retrieve the status of a task.
</span>  1505    <span class="xdoc">     *
</span>  1506    <span class="xdoc">     *  Task_stat retrieves attribute values and status information about a 
</span>  1507    <span class="xdoc">     *  task.
</span>  1508    <span class="xdoc">     *  
</span>  1509    <span class="xdoc">     *  Status information is returned through statbuf, which references a
</span>  1510    <span class="xdoc">     *  structure of type {<b>@link</b> #Stat}.
</span>  1511    <span class="xdoc">     *  
</span>  1512    <span class="xdoc">     *  When a task is preempted by a software or hardware interrupt, the task
</span>  1513    <span class="xdoc">     *  execution mode returned for that task by Task_stat is still 
</span>  1514    <span class="xdoc">     *  {<b>@link</b> #Mode_RUNNING}  because the task runs when the preemption ends.
</span>  1515    <span class="xdoc">     *
</span>  1516    <span class="xdoc">     *  The current task can inquire about itself by passing the output of
</span>  1517    <span class="xdoc">     *  {<b>@link</b> #self} as the first argument to Task_stat. However, the task 
</span>  1518    <span class="xdoc">     *  stack pointer (sp) in the {<b>@link</b> #Stat} structure is the value from 
</span>  1519    <span class="xdoc">     *  the previous context switch.
</span>  1520    <span class="xdoc">     *
</span>  1521    <span class="xdoc">     *  Task_stat has a non-deterministic execution time. As such, it is not
</span>  1522    <span class="xdoc">     *  recommended to call this API from Swis or Hwis.
</span>  1523    <span class="xdoc">     *
</span>  1524    <span class="xdoc">     *  <b>@param(statbuf)</b> pointer to task status structure
</span>  1525    <span class="xdoc">     *
</span>  1526    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1527    <span class="xdoc">     *  statbuf cannot be NULL;
</span>  1528    <span class="xdoc">     */</span>
  1529        @DirectCall
  1530        Void stat(Stat *statbuf);
  1531    
  1532        <span class="xdoc">/*!
</span>  1533    <span class="xdoc">     *  ======== getMode ========
</span>  1534    <span class="xdoc">     *  Retrieve the {<b>@link</b> #Mode} of a task.
</span>  1535    <span class="xdoc">     */</span>
  1536        @DirectCall
  1537        Mode getMode();
  1538    
  1539        <span class="xdoc">/*!
</span>  1540    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1541    <span class="xdoc">     *  ======== block ========
</span>  1542    <span class="xdoc">     *  Block a task.
</span>  1543    <span class="xdoc">     *
</span>  1544    <span class="xdoc">     *  Remove a task from its ready list.
</span>  1545    <span class="xdoc">     *  The effect of this API is manifest the next time the internal
</span>  1546    <span class="xdoc">     *  Task scheduler is invoked. 
</span>  1547    <span class="xdoc">     *  This can be done directly by embedding the call within a 
</span>  1548    <span class="xdoc">     *  {<b>@link</b> #disable}/{<b>@link</b> #restore} block.
</span>  1549    <span class="xdoc">     *  Otherwise, the effect will be manifest as a result of processing
</span>  1550    <span class="xdoc">     *  the next dispatched interrupt, or by posting a Swi, or by falling
</span>  1551    <span class="xdoc">     *  through the task function.
</span>  1552    <span class="xdoc">     *
</span>  1553    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1554    <span class="xdoc">     *  If called from within a Hwi or a Swi, or main(), there is no need 
</span>  1555    <span class="xdoc">     *  to embed the call within a {<b>@link</b> #disable}/{<b>@link</b> #restore} block.
</span>  1556    <span class="xdoc">     */</span>
  1557        @DirectCall
  1558        Void block();
  1559    
  1560        <span class="xdoc">/*!
</span>  1561    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1562    <span class="xdoc">     *  ======== unblock ========
</span>  1563    <span class="xdoc">     *  Unblock a task.
</span>  1564    <span class="xdoc">     *
</span>  1565    <span class="xdoc">     *  Place task in its ready list.
</span>  1566    <span class="xdoc">     *  The effect of this API is manifest the next time the internal
</span>  1567    <span class="xdoc">     *  Task scheduler is invoked. 
</span>  1568    <span class="xdoc">     *  This can be done directly by embedding the call within a 
</span>  1569    <span class="xdoc">     *  {<b>@link</b> #disable}/{<b>@link</b> #restore} block.
</span>  1570    <span class="xdoc">     *  Otherwise, the effect will be manifest as a result of processing
</span>  1571    <span class="xdoc">     *  the next dispatched interrupt, or by posting a Swi, or by falling
</span>  1572    <span class="xdoc">     *  through the task function.
</span>  1573    <span class="xdoc">     *
</span>  1574    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>  1575    <span class="xdoc">     *  If called from within a Hwi or a Swi, or main(), there is no need 
</span>  1576    <span class="xdoc">     *  to embed the call within a {<b>@link</b> #disable}/{<b>@link</b> #restore} block.
</span>  1577    <span class="xdoc">     */</span>
  1578        @DirectCall
  1579        Void unblock();
  1580    
  1581        <span class="xdoc">/*!
</span>  1582    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1583    <span class="xdoc">     *  ======== blockI ========
</span>  1584    <span class="xdoc">     *  Block a task.
</span>  1585    <span class="xdoc">     *
</span>  1586    <span class="xdoc">     *  Remove a task from its ready list.
</span>  1587    <span class="xdoc">     *  Must be called within Task_disable/Task_restore block
</span>  1588    <span class="xdoc">     *  with interrupts disabled.
</span>  1589    <span class="xdoc">     *  This API is meant to be used internally.
</span>  1590    <span class="xdoc">     */</span>
  1591        @DirectCall
  1592        Void blockI();
  1593    
  1594        <span class="xdoc">/*!
</span>  1595    <span class="xdoc">     *  <b>@_nodoc</b>
</span>  1596    <span class="xdoc">     *  ======== unblockI ========
</span>  1597    <span class="xdoc">     *  Unblock a task.
</span>  1598    <span class="xdoc">     *
</span>  1599    <span class="xdoc">     *  Place task in its ready list.
</span>  1600    <span class="xdoc">     *  Must be called within Task_disable/Task_restore block
</span>  1601    <span class="xdoc">     *  with interrupts disabled.
</span>  1602    <span class="xdoc">     *  This API is meant to be used internally.
</span>  1603    <span class="xdoc">     *
</span>  1604    <span class="xdoc">     *  <b>@param(hwiKey)</b> key returned from Hwi_disable()
</span>  1605    <span class="xdoc">     */</span>
  1606        @DirectCall
  1607        Void unblockI(UInt hwiKey);
  1608    
  1609    
  1610    <span class=key>internal</span>:   <span class="comment">/* not for client use */</span>
  1611    
  1612        <span class="xdoc">/*! Target-specific support functions. */</span>
  1613        <span class=key>proxy</span> SupportProxy <span class=key>inherits</span> ti.sysbios.interfaces.ITaskSupport;
  1614    
  1615        <span class="comment">/*
</span>  1616    <span class="comment">     *  ======== schedule ========
</span>  1617    <span class="comment">     *  Find highest priority ready task and invoke it.
</span>  1618    <span class="comment">     *
</span>  1619    <span class="comment">     *  Must be called with interrupts disabled.
</span>  1620    <span class="comment">     */</span>
  1621        Void schedule();
  1622    
  1623        <span class="comment">/*
</span>  1624    <span class="comment">     *  ======== enter ========
</span>  1625    <span class="comment">     *  Task's initial entry point before entering task function.
</span>  1626    <span class="comment">     */</span>
  1627        Void enter();
  1628    
  1629        <span class="comment">/*
</span>  1630    <span class="comment">     *  ======== sleepTimeout ========
</span>  1631    <span class="comment">     *  This function is the clock event handler for sleep.
</span>  1632    <span class="comment">     */</span>
  1633        Void sleepTimeout(UArg arg);
  1634    
  1635        <span class="comment">/*
</span>  1636    <span class="comment">     *  ======== postInit ========
</span>  1637    <span class="comment">     *  finish initializing static and dynamic Tasks
</span>  1638    <span class="comment">     */</span>
  1639        Int postInit(Object *swi, Error.Block *eb);
  1640    
  1641        <span class="comment">/*
</span>  1642    <span class="comment">     *  Number of statically constructed Task objects.
</span>  1643    <span class="comment">     *  Shouldn't be set directly by the user's
</span>  1644    <span class="comment">     *  config (it gets set by instance$static$init).
</span>  1645    <span class="comment">     */</span>
  1646        <span class=key>config</span> UInt numConstructedTasks = 0;
  1647    
  1648        <span class="comment">/*
</span>  1649    <span class="comment">     *  ======== allBlockedFunction ========
</span>  1650    <span class="comment">     *  default function to be called
</span>  1651    <span class="comment">     */</span>
  1652        Void allBlockedFunction();
  1653    
  1654        <span class="comment">/*
</span>  1655    <span class="comment">     *  ======== deleteTerminatedTasksFunc ========
</span>  1656    <span class="comment">     *  Idle func that deletes the first terminated task it finds
</span>  1657    <span class="comment">     *  in the queue of dynamically created tasks
</span>  1658    <span class="comment">     */</span>
  1659        Void deleteTerminatedTasksFunc();
  1660    
  1661        <span class="comment">/* 
</span>  1662    <span class="comment">     *  Common object used by all blocked tasks to enable Task_delete()
</span>  1663    <span class="comment">     *  to remove a task from any pend Q it is placed on while blocked.
</span>  1664    <span class="comment">     */</span>
  1665        <span class=key>struct</span> PendElem {
  1666            Queue.Elem              qElem;
  1667            Task.Handle             task;
  1668            Clock.Handle            clock;
  1669        };
  1670    
  1671        <span class=key>struct</span> Instance_State {
  1672            Queue.Elem      qElem;      <span class=comment>// Task's readyQ element</span>
  1673            volatile Int    priority;   <span class=comment>// Task priority</span>
  1674            UInt            mask;       <span class=comment>// curSet mask = 1 &lt;&lt; priority</span>
  1675            Ptr             context;    <span class=comment>// ptr to Task's saved context</span>
  1676                                        <span class=comment>// while not in RUNNING mode.</span>
  1677            Mode            mode;       <span class=comment>// READY, BLOCKED, RUNNING, etc</span>
  1678            PendElem        *pendElem;  <span class=comment>// ptr to Task, Semaphore, Event,</span>
  1679                                        <span class=comment>// or GateMutexPri PendElem</span>
  1680            SizeT           stackSize;  <span class=comment>// Task's stack buffer size</span>
  1681            Char            stack[];    <span class=comment>// buffer used for Task's stack</span>
  1682            IHeap.Handle    stackHeap;  <span class=comment>// Heap to allocate stack from</span>
  1683            FuncPtr         fxn;        <span class=comment>// Task function</span>
  1684            UArg            arg0;       <span class=comment>// Task function 1st arg</span>
  1685            UArg            arg1;       <span class=comment>// Task function 2nd arg</span>
  1686            Ptr             env;        <span class=comment>// Task environment pointer</span>
  1687            Ptr             hookEnv[];  <span class=comment>// ptr to Task's hook env array</span>
  1688            Bool            vitalTaskFlag; <span class=comment>// TRUE = shutdown system if</span>
  1689                                        <span class=comment>// last task like this exits</span>
  1690            Queue.Handle    readyQ;     <span class=comment>// This Task's readyQ</span>
  1691        };
  1692    
  1693        <span class=key>struct</span> Module_State {
  1694            Bool            locked;     <span class=comment>// Task scheduler locked flag</span>
  1695            volatile UInt   curSet;     <span class=comment>// Bitmask reflects readyQ states</span>
  1696            Bool            workFlag;   <span class=comment>// Scheduler work is pending.</span>
  1697                                        <span class=comment>// Optimization. Must be set</span>
  1698                                        <span class=comment>// whenever readyQs are modified.</span>
  1699            UInt            vitalTasks; <span class=comment>// number of tasks with</span>
  1700                                        <span class=comment>// vitalTaskFlag = true</span>
  1701            Handle          curTask;    <span class=comment>// current Task instance</span>
  1702            Queue.Handle    curQ;       <span class=comment>// current Task's readyQ</span>
  1703            Queue.Object    readyQ[];   <span class=comment>// Task ready queues</span>
  1704            Queue.Object    inactiveQ;  <span class=comment>// Task's with -1 priority</span>
  1705            Queue.Object    terminatedQ;<span class=comment>// terminated dynamically created Tasks</span>
  1706            Handle          idleTask;   <span class=comment>// Idle Task</span>
  1707            Handle          constructedTasks[]; <span class=comment>// array of statically </span>
  1708                                        <span class=comment>// constructed Tasks</span>
  1709        };
  1710    }
  1711    
  1712    <span class="comment">/*
</span>  1713    <span class="comment"> *  @(#) ti.sysbios.knl; 2, 0, 0, 0,552; 5-18-2012 06:05:55; /db/vtree/library/trees/avala/avala-q37x/src/ xlibrary
</span>  1714    <span class="comment">
</span>  1715    <span class="comment"> */</span>
  1716    
</pre>
</body></html>
